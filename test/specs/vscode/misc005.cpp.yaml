- source: '// '
- source: // CEKO LIBRARY
- source: // This is a library written and maintained by Jeff Hykin
- source: >-
    // the handlful of outside sources that were used are cited in the
    definition of functions that used them
- source: '// '
- source: '#ifndef CEKO_LIBRARY '
- source: '#define CEKO_LIBRARY'
- source: '// includes '
- source: '    #include <ios>                   // part of creating clear_cin'
- source: '    #include <istream>               // part of creating clear_cin'
- source: '    #include <iostream>              // cout , getline '
- source: '    #include <string>                // strings '
- source: '    #include <sstream>               // stringstreams '
- source: '    #include <vector>                // vectors'
- source: '    #include <cmath>                 // abs , pow '
- source: '    #include <regex>                 // regular expressions '
- source: '    #include <stdlib.h>              // exit(0) '
- source: '    #include <stdio.h>               //'
- source: '    #include <iomanip>               // setw , setprecision , showpoint , fixed '
- source: '    #include <limits>                // inf, max:: '
- source: '    #include <fstream>               // fstream , .open() , .close()'
- source: '    #include <algorithm>             // min ()'
- source: '    #include <random>                // rand()'
- source: '    #include <cctype>                // isalpha()'
- source: '    #include <sys/time.h>            // gettimeofday()'
- source: '    #include <time.h>                // time()'
- source: '    #include <ctime>                 // time stuff'
- source: '    #include <chrono>                // sleep_for() , sleep_until'
- source: '    #include <thread>                // system_clock, seconds'
- source: '    #include <map>                   // maps / dictionarys '
- source: '    #include <bitset>                // binary output/input'
- source: '    #include <sys/mman.h>            // used in ReadFile'
- source: '    #include <sys/stat.h>            // used in ReadFile'
- source: '    #include <fcntl.h>               // used in ReadFile, used in Threads'
- source: '    #include <pthread.h>             // threads '
- source: '    #include <type_traits>           // used in converting lambda to function pointer '
- source: '    #include <utility>               // used in converting lambda to function pointer '
- source: '// defines '
- source: '    // name space '
- source: '        using namespace std;'
- source: '        using namespace this_thread; // sleep_for, sleep_until'
- source: '        using namespace chrono;      // nanoseconds, system_clock, seconds  '
- source: '    // Constants'
- source: '        #define Infinite    numeric_limits<long double>::infinity()'
- source: '        #define DoubleMax   1.79769e+308'
- source: '        #define Pi          3.1415926535897932384626'
- source: '// ToDo '
- source: '    // range'
- source: '    // timing functions'
- source: '    // vector '
- source: '        // add -- overload to vector '
- source: '    // bool '
- source: '        // make it a thing!!'
- source: '        // Custom Yes/No'
- source: '        // [] overload '
- source: '        // implicit overload'
- source: '        // = overload  '
- source: '    // Number  '
- source: '        // handle big numbers'
- source: '        // correct comparison '
- source: '    // String  '
- source: '        // make it a thing!!'
- source: '        // [] overload w/ -1 working '
- source: '        // Regex, make XD regex '
- source: '            // find , replace , for '
- source: '    // Grid    '
- source: '        // make it a thing!!'
- source: '        // overload multiple []'
- source: '        // lots of member functions '
- source: '        // * , / , +  <> << >>'
- source: '    // List    '
- source: '        // add AskList()'
- source: '        // overload list {} so it can be declared like a vector '
- source: '        // add more member functions to list, '
- source: '            // RemoveDuplicates()'
- source: '            // Reverse()'
- source: '            // add math functions to lists (Sum, Average, Mean, Max, Min, Random, etc)'
- source: '        // implicit conversion for lists '
- source: '        // allow range-based loop'
- source: '        // operator overloads for list'
- source: '            // +'
- source: '            // != '
- source: '            // ++'
- source: '            // <<   // for non-streams'
- source: '            // >>   // for non-streams'
- source: '            // <'
- source: '            // >'
- source: '            // == '
- source: '            // <='
- source: '            // <<='
- source: '            // =>>'
- source: '            // &&   // and ''and'' operator '
- source: '            // , '
- source: '            // . '
- source: '        // allow for removal of items via a negative index .Remove(-1)'
- source: '        // think about adding dual vector_ data holders, so that AddToTop can be as efficient as AddToBottom'
- source: '    // Item    '
- source: '        // add AskItem()!'
- source: '        // add VisualFormat '
- source: '        // overload item[] so they can reference lists!!'
- source: '        // add more memeber functions to item '
- source: '            // Math '
- source: '                // Abs  '
- source: '        // overload moar things!'
- source: '            // ++'
- source: '            // --'
- source: '            // != '
- source: '            // <<   // for non-streams'
- source: '            // >>   // for non-streams'
- source: '            // <'
- source: '            // >'
- source: '            // == '
- source: '            // <='
- source: '            // <<='
- source: '            // =>>'
- source: '            // , '
- source: '            // . '
- source: '        // make item deal in_ long double type'
- source: '        // make item fix a lot of the precision issues '
- source: '        // Explore possibilty of using pointers to create Item references '
- source: // function declares and variables
- source: '    void            ClearScreen                ();'
- source: '    streamsize      FlushCin                   ();'
- source: '    void            Pause                      ();'
- source: '    void            System                     (string input_string);'
- source: '    string          Getline                    ();'
- source: '    string          Getline                    ( string&  input_string  );'
- source: '    string          Getline                    ( istream& input_stream  );'
- source: '    string          Getline                    ( istream& input_stream, string& input_string );'
- source: '    string          StreamAsString             ( istream& in_ );'
- source: '    string          StreamStatus               ( istream& in_ );'
- source: '    string          Literal                    ( string input );'
- source: '    string          Literal                    ( char   input );'
- source: '    bool            IsAllUpperCase             ( string input );'
- source: '    bool            IsAllUpperCase             ( char   input );'
- source: '    bool            Is__CharIn__String         ( char   test_val , string input_string );'
- source: '    string          EverythingUpTo             ( char end_symbol, istream& input_stream);'
- source: '    string          EverythingUpTo             ( char end_symbol);'
- source: '    void            EndProgram                 ();'
- source: '    void            Poke                       ( string id_ );'
- source: '    istream&        StreamFailed               ( istream& input_stream );'
- source: '    bool            DidStreamFail              ( istream& input_stream );'
- source: '    bool            EndOfStream                ( istream& input_stream );'
- source: '    bool            StreamMatchesString        ( istream& input_stream, string  input_string );'
- source: '    template <class ANYTYPE> string          Type(ANYTYPE input);'
- source: '    template <class ANYTYPE> string AsString(const ANYTYPE& input);'
- source: '    pthread_mutex_t mutex_for_output = PTHREAD_MUTEX_INITIALIZER;'
- source: ////////////////////////
- source: //
- source: //  Functions
- source: //
- source: ////////////////////////
- source: '    // Debugging and errors '
- source: '        // there is one more Debugging tool inside the , operator overload '
- source: '        // (should be in the ''print'' section near the bottom)'
- source: '        bool Debugging = true; // a switch for turning Debugging on and off '
- source: '        struct Errors'
- source: '            {'
- source: '                string info;'
- source: '                Errors(string input_error) { info = input_error; }'
- source: '            };'
- source: '                ostream& operator<<(ostream& output_stream, const Errors& input_error)'
- source: '                    {   return output_stream << input_error.info; }'
- source: '                void Error( string input_error )'
- source: '                    {'
- source: '                        throw Errors( input_error );'
- source: '                    }'
- source: '                void error( string input_error )'
- source: '                    {'
- source: '                        throw Errors(input_error);'
- source: '                    }'
- source: '        #define POKE cout << "here"; EndProgram(); '
- source: '        int COUNTER =0;'
- source: '    // advanced things'
- source: '        // Convertion of lambda into function pointer'
- source: '            // https://stackoverflow.com/a/45365798/4367134'
- source: '            // depends on:'
- source: '            //    #include<type_traits>'
- source: '            //    #include<utility>'
- source: '            // example usage:'
- source: '                // int i = 42;'
- source: '                // // string is the return type of the lambda function'
- source: '                // auto function_ptr_1 = convertToFuncPtr<string()>([&]{cout << i; return "hello;";});'
- source: '            template<typename Callable>'
- source: '            union storage'
- source: '                {'
- source: '                    storage() {}'
- source: '                    decay_t<Callable> callable;'
- source: '                };'
- source: '            template<int, typename Callable, typename Ret, typename... Args>'
- source: '            auto internalConversionToFuncPtr(Callable&& a_callable, Ret (*)(Args...))'
- source: '                {'
- source: '                    static bool used = false;'
- source: '                    static storage<Callable> a_storage_of_callable;'
- source: '                    using type = decltype(a_storage_of_callable.callable);'
- source: '                    if(used) {'
- source: '                        a_storage_of_callable.callable.~type();'
- source: '                    }'
- source: '                    new (&a_storage_of_callable.callable) type(forward<Callable>(a_callable));'
- source: '                    used = true;'
- source: '                    return [](Args... args) -> Ret {'
- source: '                        return Ret(a_storage_of_callable.callable(forward<Args>(args)...));'
- source: '                    };'
- source: '                }'
- source: '            template<typename RETURN_TYPE, int N = 0, typename Callable>'
- source: '            RETURN_TYPE* convertToFunctionPointer(Callable&& c)'
- source: '                {'
- source: '                    return internalConversionToFuncPtr<N>(forward<Callable>(c), (RETURN_TYPE*)nullptr);'
- source: '                }'
- source: '    // Operator Overloads'
- source: '        // vector '
- source: '            // << >>'
- source: '                // template <class ANYTYPE> ostream& operator<<(ostream& output_stream, const vector<ANYTYPE>& input_vector)'
- source: '                //     {'
- source: '                //         for ( int LoopNumber = 1 ; LoopNumber <= input_vector.size(); LoopNumber++ ) '
- source: '                //             { '
- source: '                //                 output_stream << input_vector[LoopNumber-1] << ''\n'';'
- source: '                //             }'
- source: '                //         return output_stream;'
- source: '                //     }'
- source: '                // alternative output for vector'
- source: '                template <class ANYTYPE> ostream& operator<<(ostream& output_stream, const vector<ANYTYPE>& input_vector)'
- source: '                    {'
- source: '                        output_stream << "[ ";'
- source: '                        for ( int LoopNumber = 1 ; LoopNumber <= input_vector.size(); LoopNumber++ ) '
- source: '                            { '
- source: '                                output_stream << input_vector[LoopNumber-1] << ", ";'
- source: '                            }'
- source: '                        return output_stream << "]";'
- source: '                    }'
- source: '                template <class ANYTYPE> istream& operator>>(istream& input_stream,     vector<ANYTYPE>& input_ )'
- source: '                    {'
- source: '                        input_ = {};'
- source: '                        ANYTYPE element_holder;'
- source: '                        char should_always_be_a_newline;'
- source: '                        while(input_stream >> element_holder) '
- source: '                        { '
- source: '                            input_.push_back(element_holder);'
- source: '                            input_stream.get(should_always_be_a_newline);'
- source: '                            if (should_always_be_a_newline != ''\n'')'
- source: '                                return StreamFailed(input_stream);'
- source: '                        }'
- source: '                        return input_stream;'
- source: '                    }'
- source: '            // +    '
- source: '                template <class ANYTYPE> vector<ANYTYPE> operator+(const vector<ANYTYPE>& vec1, const vector<ANYTYPE>& vec2)'
- source: '                    {'
- source: '                        vector<ANYTYPE> vec3 = vec1;'
- source: '                        vec3.reserve(vec1.size()+vec2.size());'
- source: '                        for ( ANYTYPE each : vec2 ) '
- source: '                            vec3.push_back(each);'
- source: '                        return vec3;'
- source: '                    }'
- source: '                template <class ANYTYPE> vector<ANYTYPE> operator+(const vector<ANYTYPE>& vec1, const ANYTYPE input_)'
- source: '                    {   '
- source: '                        vector<ANYTYPE> vec2 = vec1;'
- source: '                        vec2.push_back(input_);'
- source: '                        return vec2;'
- source: '                    }'
- source: '                template <class ANYTYPE> vector<ANYTYPE> operator+( const ANYTYPE input_, const vector<ANYTYPE>& vec1)'
- source: '                    {   '
- source: '                        vector<ANYTYPE> vec2 = vec1;'
- source: '                        vec2.insert(vec2.begin(),input_);'
- source: '                        return vec2;'
- source: '                    }'
- source: '        // map    '
- source: '            template <class ANYTYPE, class ANYSECONDTYPE> ostream& operator<<(ostream& output_stream, const pair<ANYSECONDTYPE, ANYTYPE>& input_pair)'
- source: '                {'
- source: '                    return output_stream << input_pair.first << '':'' << input_pair.second;'
- source: '                }        '
- source: '            template <class ANYTYPE, class ANYSECONDTYPE> ostream& operator<<(ostream& output_stream, const map<ANYSECONDTYPE , ANYTYPE>& input_map )'
- source: '                {'
- source: '                    for ( pair<ANYSECONDTYPE, ANYTYPE> each : input_map ) '
- source: '                    { '
- source: '                        output_stream << each << ''\n'';'
- source: '                    }'
- source: '                    return output_stream;'
- source: '                }'
- source: '            template <class ANYTYPE, class ANYSECONDTYPE> istream& operator>>(istream& input_stream,    pair<ANYSECONDTYPE, ANYTYPE>& input_pair)'
- source: '                {'
- source: '                    char should_always_be_a_colon;'
- source: '                    ANYTYPE first_value;'
- source: '                    ANYSECONDTYPE second_value;'
- source: '                    input_stream >> first_value >> should_always_be_a_colon >> second_value;'
- source: '                    input_pair.second = second_value;'
- source: '                    input_pair.first = first_value;'
- source: '                    return input_stream;'
- source: '                }'
- source: '            template <class ANYTYPE, class ANYSECONDTYPE> istream& operator>>(istream& input_stream,     map<ANYSECONDTYPE , ANYTYPE>& input_map )'
- source: '                {'
- source: '                    input_map.clear();'
- source: '                    pair<ANYTYPE,ANYSECONDTYPE> pair_holder;'
- source: '                    char should_always_be_a_newline;'
- source: '                    while(input_stream >> pair_holder) '
- source: '                    { '
- source: '                        input_map[pair_holder.first] = pair_holder.second;'
- source: '                        input_stream.get(should_always_be_a_newline);'
- source: '                        if (should_always_be_a_newline != ''\n'')'
- source: '                            return StreamFailed(input_stream);'
- source: '                    }'
- source: '                    return input_stream;'
- source: '                }'
- source: '    // Core helper functions '
- source: '        // indent           '
- source: '            // data for indent '
- source: '            int    const INDENT_SIZE = 4;'
- source: '            string const INDENT      = string(INDENT_SIZE, '' '');'
- source: '            // functions '
- source: '            template <class ANYTYPE> string        Indent                     (ANYTYPE input_)'
- source: '                {'
- source: '                    stringstream a_stream;'
- source: '                    a_stream << input_;'
- source: '                    char a_char;'
- source: '                    string output_string = INDENT;'
- source: '                    while (a_stream.get(a_char))'
- source: '                        {'
- source: '                            if (a_char == ''\n'')'
- source: '                                {'
- source: '                                    output_string = output_string + "\n" + INDENT;'
- source: '                                }'
- source: '                            else '
- source: '                                output_string = output_string + a_char;'
- source: '                        }'
- source: '                    return output_string;'
- source: '                }'
- source: '            string          Indent                     (istream& input_)'
- source: '                {'
- source: '                    string output = StreamAsString(input_);'
- source: '                    return Indent(output);'
- source: '                }'
- source: '            string          Indent                     (stringstream& input_)'
- source: '            {'
- source: '                string output = StreamAsString(input_);'
- source: '                return Indent(output);'
- source: '            }'
- source: '            // create an unindent for streams only'
- source: '            // should always return a \n at the end '
- source: '            // if it returns "" it failed'
- source: '            string        Input_Unindent             (istream& in_)'
- source: '                {'
- source: '                    bool local_debug = false;'
- source: '                    if (local_debug) cout << "starting Input_Unindent()\n";'
- source: '                    char char_holder;'
- source: '                    string unindented_stuff ="";'
- source: '                    // for each line '
- source: '                    while(true)'
- source: '                        {'
- source: '                            // get the first char'
- source: '                            in_.get(char_holder);'
- source: '                            // break if end of file '
- source: '                            if (in_.eof()) '
- source: '                                {'
- source: '                                    if (local_debug) cout << "exiting via end of input\n";'
- source: '                                    break;'
- source: '                                }'
- source: '                            // put the char back into the stream '
- source: '                            in_.unget();'
- source: '                            if (local_debug) cout << "char is:" << Literal(char_holder) << ''\n'';'
- source: '                            // if it doesn start with an indent, break'
- source: '                            if (char_holder != '' '') '
- source: '                                {'
- source: '                                    if (local_debug) cout << "exiting via no indent start\n";'
- source: '                                    break;'
- source: '                                }'
- source: '                            // if for some reason the stream has a space '
- source: '                            // but is not fully indented'
- source: '                            // then fail (this will mess up the stream because)'
- source: '                            // the spaces cannot be (reliably) un-got'
- source: '                            if (!StreamMatchesString(in_, INDENT)) '
- source: '                                    {'
- source: '                                        if (local_debug) cout << "exiting via started with space but not indent\n";'
- source: '                                        if (local_debug) cout << "counter is:" << COUNTER << ''\n'';'
- source: '                                        return "";'
- source: '                                    }'
- source: '                            // put the whole line into a string'
- source: '                            string next_line = EverythingUpTo(''\n'',in_);'
- source: '                            // if there wasnt a newline at the end then fail '
- source: '                            if (next_line[next_line.size()-1] != ''\n'') '
- source: '                                {'
- source: '                                    if (local_debug) cout << "exiting via no newline at end of string\n";'
- source: '                                    if (local_debug) cout << "line was:\n" << Literal(next_line);'
- source: '                                    return "";'
- source: '                                }'
- source: '                            unindented_stuff += next_line;'
- source: '                        }'
- source: '                    return unindented_stuff;'
- source: '                }'
- source: '        // Random numbers   '
- source: '            float Rand  ( ) { return ( rand() % 10000 ) / 10000.0;                         }'
- source: '            float Randn ( ) { return sqrt( -2 * log( Rand() )  ) * cos( 2 * Pi * Rand() ); } '
- source: '        // Time'
- source: '            long long    CurrentTimeInMicroSeconds()'
- source: '                {'
- source: '                    struct timeval a_time;'
- source: '                    gettimeofday(&a_time, 0);'
- source: '                    return a_time.tv_sec * 1000000 + a_time.tv_usec;'
- source: '                }'
- source: '            long         NumberOfMicrosecondsBetween(struct timeval& start_time, struct timeval& end_time)'
- source: '                {'
- source: '                    long seconds       = end_time.tv_sec  - start_time.tv_sec;'
- source: '                    long micro_seconds = end_time.tv_usec - start_time.tv_usec;'
- source: '                    if (micro_seconds < 0)'
- source: '                        {'
- source: '                            micro_seconds += (int)1e6;'
- source: '                            seconds--;'
- source: '                        }'
- source: '                    return (seconds * 1000000 + micro_seconds);'
- source: '                }'
- source: '            void         BriefDelay (               ) { sleep_for( milliseconds(           200                   ) ); }'
- source: '            void         BriefDelay (double seconds_) { sleep_for( milliseconds(static_cast<int>(seconds_ * 100) ) ); }'
- source: '            void         LittleRandomDelay ()         { BriefDelay( Randn() + 1 ); }'
- source: '            const string currentDateTime   () '
- source: '                {'
- source: '                    //  modified this a bit from http://stackoverflow.com/questions/997946/how-to-get-current-time-and-date-in_-c'
- source: '                    // depends on:'
- source: '                    //     #include <iostream>'
- source: '                    //     #include <string>'
- source: '                    //     #include <stdio.h>'
- source: '                    //     #include <time.h>'
- source: '                    time_t     now = time(0);'
- source: '                    struct tm  tstruct;'
- source: '                    char       buf[80];'
- source: '                    tstruct = *localtime(&now);'
- source: '                    // Visit http://en.cppreference.com/w/cpp/chrono/c/strftime'
- source: '                    // for more information about date/time format'
- source: '                    strftime(buf, sizeof(buf), "%Y-%m-%d  %X", &tstruct);'
- source: '                    return buf;'
- source: '                }'
- source: '        // Stream functions '
- source: '            // mostly for cout, cin '
- source: '                template <typename ANYTYPE> streamsize FlushStream (basic_istream   <ANYTYPE>& input_stream,   bool always_discard = false )'
- source: '                    {'
- source: '                        //  this code is a visually modified version of the code from: '
- source: '                        //  https://www.daniweb.com/programming/software-development/threads/90228/flushing-the-input-stream'
- source: '                        //  (which is a great explaination of the process ) '
- source: '                        //  it allows correct clearing of the cin buffer '
- source: '                        //  '
- source: '                        //  depends on:'
- source: '                        //         #include <ios>'
- source: '                        //         #include <istream>'
- source: '                        //         #include <limits>'
- source: '                        streamsize num_of_chars_discarded = 0;'
- source: '                        if     ( always_discard '
- source: '                            || (    input_stream.rdbuf()->sungetc() != char_traits<ANYTYPE>::eof()'
- source: '                                 && input_stream.get()              != input_stream.widen ( ''\n'' )       ) )'
- source: '                        {'
- source: '                                // The stream is good, and we haven''t'
- source: '                                // read a full line yet, so clear it out'
- source: '                                input_stream.ignore ( numeric_limits<streamsize>::max(), input_stream.widen ( ''\n'' ) );'
- source: '                                num_of_chars_discarded = input_stream.gcount();'
- source: '                        }'
- source: '                        return num_of_chars_discarded;'
- source: '                    }'
- source: '                void            ClearScreen                ()'
- source: '                    {'
- source: '                        cout << "\033[2J\033[1;1H"; // http://stackoverflow.com/questions/17335816/clear-screen-using-c'
- source: '                    } '
- source: '                streamsize      FlushCin                   ()'
- source: '                    { '
- source: '                        return FlushStream ( cin ); '
- source: '                    }'
- source: '                string          Getline                    ()'
- source: '                    {'
- source: '                        string input_data;'
- source: '                        FlushCin();'
- source: '                        getline(cin, input_data);'
- source: '                        return input_data;'
- source: '                    }'
- source: '                string          Getline                    ( string&  input_string  )'
- source: '                    {'
- source: '                        FlushCin();'
- source: '                        getline(cin, input_string);'
- source: '                        return input_string;'
- source: '                    }'
- source: '                string          Getline                    ( istream& input_stream  )'
- source: '                    {'
- source: '                        string input_string;'
- source: '                        FlushCin();'
- source: '                        getline(input_stream, input_string);'
- source: '                        return input_string;'
- source: '                    }'
- source: '                string          Getline                    ( istream& input_stream, string& input_string )'
- source: '                    {'
- source: '                        FlushCin();'
- source: '                        getline(input_stream, input_string);'
- source: '                        return input_string;'
- source: '                    }'
- source: '                void            Pause                      ()'
- source: '                    {'
- source: '                        FlushCin();'
- source: '                        if (!cin)'
- source: '                            cin.clear();'
- source: '                        cin.ignore();'
- source: '                    } '
- source: '                void BackSpace (int    number_of_places )'
- source: '                    { '
- source: '                        { int Max_Value =  number_of_places     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { '
- source: '                            cout << ''\b'';'
- source: '                            cout << '' '';'
- source: '                            cout << ''\b'';'
- source: '                            cout.flush();'
- source: '                            LittleRandomDelay();'
- source: '                         } } '
- source: '                    } '
- source: '                void TypeOut   (string input_string     )'
- source: '                    {'
- source: '                        { int Max_Value =  input_string .size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { int EachChar = LoopNumber - 1;  '
- source: '                            cout.flush();'
- source: "                            cout << input_string[\_EachChar ];"
- source: '                            cout.flush();'
- source: '                            LittleRandomDelay();'
- source: '                        } }'
- source: '                        BriefDelay(7);'
- source: '                    }'
- source: '            // stream helpers '
- source: '                string          StreamAsString             ( istream& in_ )'
- source: '                    {'
- source: '                        stringstream output;'
- source: '                        char each_char;'
- source: '                        while ( in_.get(each_char) ) '
- source: '                            output << each_char;'
- source: '                        string output_str = output.str();'
- source: '                        return output_str;'
- source: '                    }'
- source: '                string          StreamStatus               ( istream& in_ )'
- source: '                    {'
- source: '                        string output;'
- source: '                        // good'
- source: '                        if (in_.good())'
- source: '                            output += "Good: Yes\n";'
- source: '                        else '
- source: '                            output += "Good: No\n";'
- source: '                        // eof'
- source: '                        if (in_.eof ())'
- source: '                            output += "EOF : Yes\n";'
- source: '                        else'
- source: '                            output += "EOF : No\n";'
- source: '                        // fail '
- source: '                        if (in_.fail())'
- source: '                            output += "Fail: Yes\n";'
- source: '                        else'
- source: '                            output += "Fail: No\n";'
- source: '                        // bad'
- source: '                        if (in_.bad ())'
- source: '                            output += "Bad : Yes\n";'
- source: '                        else'
- source: '                            output += "Bad : No\n";'
- source: '                        return output;'
- source: '                    }'
- source: '                istream&        StreamFailed               ( istream& input_stream )'
- source: '                    {'
- source: '                        input_stream.clear();'
- source: '                        input_stream.clear(ios_base::failbit);'
- source: '                        return input_stream;'
- source: '                    }'
- source: '                bool            DidStreamFail              ( istream& input_stream )'
- source: '                    {'
- source: '                        if (input_stream.eof())'
- source: '                            {'
- source: '                                return false;'
- source: '                            }'
- source: '                        else if (input_stream.fail())'
- source: '                            {'
- source: '                                return true ;'
- source: '                            }'
- source: '                    }'
- source: '                bool            EndOfStream                ( istream& input_stream )'
- source: '                    {'
- source: '                        if (input_stream.eof())'
- source: '                            return true;'
- source: '                        return false;'
- source: '                    }'
- source: '                bool            StreamMatchesString        ( istream& input_stream, string  input_string )'
- source: '                    {'
- source: '                        char char_;'
- source: '                        { int Max_Value =  input_string.size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) {'
- source: '                                // if the stream runs out of characters, false '
- source: '                                if (   !(  input_stream.get(char_)  )     )'
- source: '                                    return false;'
- source: '                                // if string doesn''t match, false '
- source: '                                if ( char_ != input_string[LoopNumber-1] )'
- source: '                                    return false;'
- source: '                         } }'
- source: '                        return true;'
- source: '                    }'
- source: '                string          EverythingUpTo             ( char end_symbol, istream& input_stream)'
- source: '                    {'
- source: '                       char char_;'
- source: '                       string output;'
- source: '                       while (input_stream.get(char_))'
- source: '                            {'
- source: '                                output = output + char_ ;'
- source: '                                if (char_ == end_symbol)'
- source: '                                    return output;'
- source: '                            }'
- source: '                        return output;'
- source: '                    }'
- source: '                string          EverythingUpTo             ( char end_symbol)'
- source: '                    {'
- source: '                       char char_;'
- source: '                       string output;'
- source: '                       while (cin.get(char_) )'
- source: '                            {'
- source: '                                output = output + char_ ;'
- source: '                                if (char_ == end_symbol)'
- source: '                                    return output;'
- source: '                            }'
- source: '                        return output;'
- source: '                    }'
- source: '        // System           '
- source: '            void  System      (string input_string)'
- source: '                {'
- source: '                    const char* conv_my_str = input_string.c_str();'
- source: '                    system(conv_my_str);'
- source: '                }'
- source: '            void  EndProgram  ()'
- source: '                    {'
- source: '                        // save a success log'
- source: '                        ofstream the_file_stream(".success.log");'
- source: '                        the_file_stream << "success";'
- source: '                        the_file_stream.close();'
- source: '                        // press enter to exit'
- source: '                        cout << "\npress enter to exit\n";'
- source: '                        Pause();'
- source: '                        exit(0);'
- source: '                    }'
- source: '            void  Poke        (string id_)'
- source: '                {'
- source: '                    cout << "Poked " << id_ << ''\n'';'
- source: '                    EndProgram();'
- source: '                }'
- source: '        // String Helpers'
- source: '            string operator*( const string&  base   , const long long&   repetitions  )'
- source: '                {'
- source: '                    string result;'
- source: '                    for (int i = 0; i < repetitions; i++)'
- source: '                        result += base;'
- source: '                    return result;'
- source: '                }'
- source: '            string operator*(const long long&   repetitions , const string&  base)'
- source: '                {'
- source: '                    string result;'
- source: '                    for (int i = 0; i < repetitions; i++)'
- source: '                        result += base;'
- source: '                    return result;'
- source: '                }'
- source: '            string Substring           ( string base, int start, int finish )'
- source: '                {'
- source: '                    if (start < 0)'
- source: '                        start = base.size() + start;'
- source: '                    else if (start > base.size())'
- source: '                        start = base.size();'
- source: '                    if (finish < 0)'
- source: '                        finish = base.size() + finish;'
- source: '                    else if (finish > base.size())'
- source: '                        finish = base.size();'
- source: '                    if (start > finish) {'
- source: '                        int swap = start;'
- source: '                        start = finish;'
- source: '                        finish = swap;'
- source: '                    }'
- source: '                    return base.substr(start, finish - start);'
- source: '                }'
- source: '            string Substring           ( string base, int start )'
- source: '                {'
- source: '                    return Substring(base, start, base.length());'
- source: '                }'
- source: '            string Join                ( vector<string> base, string delimiter )'
- source: '                {'
- source: '                    string result;'
- source: '                    for (int i = 0; i < base.size() - 1; i++)'
- source: '                        result += base[i] + delimiter;'
- source: '                    result += base[base.size() - 1];'
- source: '                    return result;'
- source: '                }'
- source: '            string Join                ( vector<string> base, char delimiter )'
- source: '                {'
- source: '                    return Join(base, string(1, delimiter));'
- source: '                }'
- source: '            string Replace             ( string base, string oldstring, string newstring )'
- source: '                {'
- source: '                    int index = 0;'
- source: '                    string current;'
- source: '                    while (index <= base.length() - oldstring.length()) {'
- source: '                        if (base.substr(index, oldstring.length()) == oldstring) {'
- source: '                            current += newstring;'
- source: '                            index += oldstring.length();'
- source: '                            continue;'
- source: '                        }'
- source: '                        current += base[index];'
- source: '                        index++;'
- source: '                    }'
- source: '                    return current;'
- source: '                }'
- source: '            string Replace             ( string base, char oldstring, string newstring )'
- source: '                {'
- source: '                    return Replace(base, string(1, oldstring), newstring);'
- source: '                }'
- source: '            string Replace             ( string base, string oldstring, char newstring )'
- source: '                {'
- source: '                    return Replace(base, oldstring, string(1, newstring));'
- source: '                }'
- source: '            string Replace             ( string base, char oldstring, char newstring )'
- source: '                {'
- source: '                    return Replace(base, string(1, oldstring), string(1, newstring));'
- source: '                }'
- source: '            string Replace             ( string base, string oldstring )'
- source: '                {'
- source: '                    return Replace(base, oldstring, "");'
- source: '                }'
- source: '            string Replace             ( string base, char oldstring )'
- source: '                {'
- source: '                    return Replace(base, string(1, oldstring), "");'
- source: '                }'
- source: '            string Strip               ( string input, char junk='' '' )'
- source: '                {'
- source: '                    if (input.size() == 0)'
- source: '                        {'
- source: '                            return "";'
- source: '                        }'
- source: '                    int num_front = -1;'
- source: '                    while (input.at(++num_front) == junk){}'
- source: '                    int num_end = input.size();'
- source: '                    while (input.at(--num_end) == junk){}'
- source: '                    return input.substr(num_front, 1+num_end - num_front);'
- source: '                }'
- source: '            string GetWhileIncluded    ( string input, string included_characters )'
- source: '                {'
- source: '                    string output = "";'
- source: '                    for (auto each : input)'
- source: '                        {'
- source: '                            // if its valid '
- source: '                            if (Is__CharIn__String(each, included_characters))'
- source: '                                {'
- source: '                                    // add it'
- source: '                                    output.push_back(each);'
- source: '                                }'
- source: '                            else'
- source: '                                {'
- source: '                                    break;'
- source: '                                }'
- source: '                        }'
- source: '                    return output;'
- source: '                }'
- source: '            string RemoveWhileIncluded ( string input, string included_characters )'
- source: '                {'
- source: '                    string output = "";'
- source: '                    int number_of_char_to_ignore = 0;'
- source: '                    for (auto each : input)'
- source: '                        {'
- source: '                            // if its valid '
- source: '                            if (Is__CharIn__String(each, included_characters))'
- source: '                                {'
- source: '                                    ++number_of_char_to_ignore;'
- source: '                                }'
- source: '                            else'
- source: '                                {'
- source: '                                    break;'
- source: '                                }'
- source: '                        }'
- source: '                    output = input.substr(number_of_char_to_ignore, output.size()-1);'
- source: '                    return output;'
- source: '                }'
- source: '            vector<string>  Split                      ( string input, char splitter )'
- source: '                {'
- source: '                    vector<string> chunks;'
- source: '                    chunks.push_back("");'
- source: '                    input = Strip(input, splitter);'
- source: '                    int char_index = -1;'
- source: '                    int chunk_index = 0;'
- source: '                    bool prev_char_was_splitter = false;'
- source: '                    while (++char_index < input.size())'
- source: '                        {'
- source: '                            char current_character = input.at(char_index);'
- source: '                            if (current_character == splitter)'
- source: '                                {'
- source: '                                    if (not prev_char_was_splitter)'
- source: '                                        {'
- source: '                                            chunks.push_back("");'
- source: '                                            ++chunk_index;'
- source: '                                        }'
- source: '                                    prev_char_was_splitter = true;'
- source: '                                    continue;'
- source: '                                }'
- source: '                            else'
- source: '                                {'
- source: '                                    prev_char_was_splitter = false;'
- source: '                                    chunks.at(chunk_index).push_back(current_character);'
- source: '                                }'
- source: '                        }'
- source: '                    return chunks;'
- source: '                }'
- source: '            template <class ANYTYPE, class ANYTYPE2> int StartIndexOfFirst__In__(ANYTYPE target_anytype, ANYTYPE2 base_anytype)'
- source: '                {'
- source: '                    // convert target to string'
- source: '                    ostringstream stream1;'
- source: '                    stream1 << target_anytype;'
- source: '                    string target = stream1.str();'
- source: '                    // convert base to string'
- source: '                    ostringstream stream2;'
- source: '                    stream2 << base_anytype;'
- source: '                    string base = stream2.str();'
- source: '                    int index = 0;'
- source: '                    while (index + target.length() <= base.length()) {'
- source: '                        if (base.substr(index, target.length()) == target)'
- source: '                            return index;'
- source: '                        index++;'
- source: '                    }'
- source: '                    return -1;'
- source: '                }'
- source: '            template <class ANYTYPE, class ANYTYPE2> int StartIndexOfLast__In__(ANYTYPE target_anytype, ANYTYPE2 base_anytype)'
- source: '                {'
- source: '                    // convert target to string'
- source: '                    ostringstream stream1;'
- source: '                    stream1 << target_anytype;'
- source: '                    string target = stream1.str();'
- source: '                    // convert base to string'
- source: '                    ostringstream stream2;'
- source: '                    stream2 << base_anytype;'
- source: '                    string base = stream2.str();'
- source: '                    int index = base.length() - target.length();'
- source: '                    while (index) {'
- source: '                        if (base.substr(index, target.length()) == target)'
- source: '                            return index;'
- source: '                        index--;'
- source: '                    }'
- source: '                    return -1;'
- source: '                }'
- source: '            template <class ANYTYPE> vector<int> Indices(string base, ANYTYPE target_anytype)'
- source: '                {'
- source: '                    // convert target to string'
- source: '                    ostringstream stream1;'
- source: '                    stream1 << target_anytype;'
- source: '                    string target = stream1.str();'
- source: '                    vector<int> indices;'
- source: '                    int index = 0;'
- source: '                    while (index + target.length() <= base.length()) {'
- source: '                        if (base.substr(index, target.length()) == target)'
- source: '                            indices.push_back(index);'
- source: '                        index++;'
- source: '                    }'
- source: '                    return indices;'
- source: '                }'
- source: '            template <class ANYTYPE> bool        Includes(string base, ANYTYPE target_anytype)'
- source: '                {'
- source: '                    // convert target to string'
- source: '                    ostringstream stream1;'
- source: '                    stream1 << target_anytype;'
- source: '                    string target = stream1.str();'
- source: '                    return (StartIndexOfFirst__In__(target, base) > -1);'
- source: '                }'
- source: '            template <class ANYTYPE> bool        Startswith(string base, ANYTYPE target_anytype)'
- source: '                {'
- source: '                    // convert target to string'
- source: '                    ostringstream stream1;'
- source: '                    stream1 << target_anytype;'
- source: '                    string target = stream1.str();'
- source: '                    if (base.length() >= target.length())'
- source: '                        return (base.substr(0, target.length()) == target);'
- source: '                    return false;'
- source: '                }'
- source: '            template <class ANYTYPE> bool        Endswith(string base, ANYTYPE target_anytype)'
- source: '                {'
- source: '                    // convert target to string'
- source: '                    ostringstream stream1;'
- source: '                    stream1 << target_anytype;'
- source: '                    string target = stream1.str();'
- source: '                    if (base.length() >= target.length())'
- source: '                        return (base.substr(base.length() - target.length()) == target);'
- source: '                    return false;'
- source: '                }'
- source: '            template <class ANYTYPE> string        the__thDigitOf__           (int position        , ANYTYPE input_)'
- source: '                {'
- source: '                    string input_as_string = to_string(input_);'
- source: '                    return input_[ input_.size() - position  ];'
- source: '                }'
- source: '            bool            IsALegitFileName           ( string attempt_filename )'
- source: '                    {'
- source: '                        // letters, numbers, and dashes (must have at least one of any of those)'
- source: '                        // allows a period only for file extentions'
- source: '                        regex is_not_obnoxious = regex("[A-Za-z_0-9\\-]+(\\.[A-Za-z]+|)");'
- source: '                        return regex_match(attempt_filename, is_not_obnoxious);'
- source: '                    }'
- source: '            string          Literal                    ( string input )'
- source: '                {'
- source: '                    char each_char;'
- source: '                    stringstream char_stream;'
- source: '                    char_stream << input;'
- source: '                    string output;'
- source: '                    int space_counter = 0;'
- source: '                    int newline_counter = 0;'
- source: '                    while (char_stream.get(each_char))'
- source: '                        {'
- source: '                            // spaces '
- source: '                            if (each_char == '' '')'
- source: '                                { '
- source: '                                    space_counter++;'
- source: '                                    if (char_stream.peek() != '' '')'
- source: '                                        {'
- source: '                                            output += "\\"+to_string(space_counter)+"SPACES";'
- source: '                                            space_counter = 0;'
- source: '                                        }'
- source: '                                }'
- source: '                            // newlines'
- source: '                            else if (each_char == ''\n'')'
- source: '                                {'
- source: '                                    newline_counter++;'
- source: '                                    if (char_stream.peek() != ''\n'')'
- source: '                                        {'
- source: '                                            output += "\\"+to_string(newline_counter)+"n\n"; '
- source: '                                            newline_counter = 0;'
- source: '                                        }'
- source: '                                }'
- source: '                            // everything else '
- source: '                            else if (each_char == ''\\'')'
- source: '                                output += "\\\\";'
- source: '                            else if (each_char == ''\t'')'
- source: '                                output += "\\t";'
- source: '                            else if (each_char == ''\0'')'
- source: '                                output += "\\0";'
- source: '                            else if (each_char == ''\r'')'
- source: '                                output += "\\r";'
- source: '                            else if (each_char == ''\v'')'
- source: '                                output += "\\v";'
- source: '                            else if (each_char == ''\b'')'
- source: '                                output += "\\b";'
- source: '                            else '
- source: '                                output += each_char;'
- source: '                        }'
- source: '                    return output;'
- source: '                }'
- source: '            string          Literal                    ( char   input )'
- source: '                {'
- source: '                    stringstream output;'
- source: '                    output << input;'
- source: '                    string output_str = output.str();'
- source: '                    return Literal(output_str);'
- source: '                }'
- source: '            bool            IsAllUpperCase             ( string input )'
- source: '                {'
- source: '                    { int Max_Value =  input .size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { int EachChar = LoopNumber - 1; '
- source: '                        if ( not isupper( input[EachChar] ) )'
- source: '                            return false;'
- source: '                        else '
- source: '                            return true;'
- source: '                    } }'
- source: '                }'
- source: '            bool            IsAllUpperCase             ( char   input )'
- source: '                {'
- source: '                    return IsAllUpperCase(AsString(input));'
- source: '                }'
- source: '            bool            Is__CharIn__String         ( char   test_val , string input_string ) '
- source: '                { '
- source: '                    for (auto each : input_string)'
- source: '                        {'
- source: '                            if (each == test_val)'
- source: '                                {'
- source: '                                    return true;'
- source: '                                }'
- source: '                        }'
- source: '                    return false;'
- source: '                } '
- source: '            vector<string>  ExtractArguments           ( string& content, string end_characters, string ignore_characters=" \t", string encapsulate_characters="\"\''", vector<pair<char,string>> encapsulating_pairs={make_pair(''('',")")})'
- source: '                {'
- source: '                    vector<string> arguments;'
- source: '                    int index = 0;'
- source: '                    vector<string> char_context_stack = {""};'
- source: '                    string previous_char_as_string = "";'
- source: '                    for (auto each : content)'
- source: '                        {'
- source: '                            index++;'
- source: '                            string context = *(char_context_stack.end()-1);'
- source: '                            // no context'
- source: '                            if (context == "")'
- source: '                                {'
- source: '                                    // if ending character then we''re done'
- source: '                                    if (Is__CharIn__String(each, end_characters))'
- source: '                                        {'
- source: '                                            // dont count the final character'
- source: '                                            index--;'
- source: '                                            break;'
- source: '                                        }'
- source: '                                    // if ignore_characters, go to next character'
- source: '                                    else if (Is__CharIn__String(each, ignore_characters))'
- source: '                                        {'
- source: '                                            // this is like continue, but needs to set a loop variable'
- source: '                                            goto SKIP_CHAR;'
- source: '                                        }'
- source: '                                    // if valid/normal'
- source: '                                    else'
- source: '                                        {'
- source: '                                            // '
- source: '                                            // add argument if needed'
- source: '                                            // '
- source: '                                            // special case if its the first argument'
- source: '                                            bool is_first_arg = (previous_char_as_string == "");'
- source: '                                            // transition to new argument'
- source: '                                            bool is_new_arg = not is_first_arg and Is__CharIn__String(*(previous_char_as_string.end()-1), ignore_characters);'
- source: '                                            if (is_first_arg or is_new_arg)'
- source: '                                                {'
- source: '                                                    arguments.push_back("");'
- source: '                                                }'
- source: '                                            // '
- source: '                                            // add the character to the argument'
- source: '                                            // '
- source: '                                            (*(arguments.end()-1)).push_back(each);'
- source: '                                            // '
- source: '                                            // check for new contexts'
- source: '                                            // '
- source: '                                            // basic encapsulator'
- source: '                                            if (Is__CharIn__String(each, encapsulate_characters))'
- source: '                                                {'
- source: '                                                    char_context_stack.push_back(AsString(each));'
- source: '                                                }'
- source: '                                            // paired encapsulators'
- source: '                                            else'
- source: '                                                {'
- source: '                                                    for (auto each_pair : encapsulating_pairs)'
- source: '                                                        {'
- source: '                                                            // if it matches the first char in a pair'
- source: '                                                            if (Is__CharIn__String(each, AsString(each_pair.first)))'
- source: '                                                                {'
- source: '                                                                    // add the other half as the context'
- source: '                                                                    char_context_stack.push_back(each_pair.second);'
- source: '                                                                }'
- source: '                                                        }'
- source: '                                                }'
- source: '                                        }'
- source: '                                }'
- source: '                            // if there is context'
- source: '                            else'
- source: '                                {'
- source: '                                    // add the character '
- source: '                                    (*(arguments.end()-1)).push_back(each);'
- source: '                                    // check if that was the end'
- source: '                                    if (Is__CharIn__String(each, context))'
- source: '                                        {'
- source: '                                            // remove the context'
- source: '                                            char_context_stack.pop_back();'
- source: '                                        }'
- source: '                                }'
- source: '                            SKIP_CHAR:'
- source: '                            previous_char_as_string = AsString(each);'
- source: '                        }'
- source: '                    // remove the parsed part'
- source: '                    content = content.substr(index, content.size()-1);'
- source: '                    return arguments;'
- source: '                }'
- source: '        // Number helpers'
- source: '            template <class ANYTYPE>'
- source: '            string ToBinary(ANYTYPE input)'
- source: '                {'
- source: '                    // depends on #include <bitset>'
- source: '                    return bitset<8>(input).to_string();'
- source: '                }'
- source: '            int BinaryToInt(string input)'
- source: '                {'
- source: '                    // depends on #include <bitset>'
- source: '                    return bitset<8>(input).to_ulong();'
- source: '                }'
- source: '            int Round ( double input_number ) { return input_number + 0.5; } '
- source: '            int Round ( float  input_number ) { return input_number + 0.5; } '
- source: '        // range'
- source: '            vector<int> Range(int lower, int increment, int upper)'
- source: '                {'
- source: '                    vector<int> result;'
- source: '                    if (increment > 0)'
- source: '                        {'
- source: '                            for (int i = lower; i < upper; i += increment)'
- source: '                                {'
- source: '                                    result.push_back(i);'
- source: '                                }'
- source: '                        }'
- source: '                    else'
- source: '                        {'
- source: '                            for (int i = lower; i > upper; i += increment)'
- source: '                                {'
- source: '                                    result.push_back(i);'
- source: '                                }'
- source: '                        }'
- source: '                    return result;'
- source: '                }'
- source: '            vector<int> Range(int lower, int upper)'
- source: '                {'
- source: '                    return Range(lower, 1, upper);'
- source: '                }'
- source: '            vector<int> Range(int upper)'
- source: '                {'
- source: '                    return Range(0, 1, upper);'
- source: '                }'
- source: '        // IO basic types '
- source: '            // CopyPaste Class IO'
- source: '                //ostream& output (ostream& out, const classname& input_)'
- source: '                //    {'
- source: '                //        // name of class '
- source: '                //        out << "classname" << ''\n'';'
- source: '                //        '
- source: '                //                stringstream data_members;'
- source: '                //                '
- source: '                //        // for each datamember'
- source: '                //        output( data_members , input_.datamember()); data_members << ''\n'';'
- source: '                //        '
- source: '                //                // format and return stream'
- source: '                //                out << Indent( data_members.str() ) << ''\n'';'
- source: '                //                return out;'
- source: '                //    }'
- source: '                //istream& input  (istream& in_,        classname& input_)'
- source: '                //    {'
- source: '                //    '
- source: '                //        // check name of type '
- source: '                //        if ( EverythingUpTo(''\n'',in_) != "classname\n")'
- source: '                //            return StreamFailed(in_);'
- source: '                //        '
- source: '                //  '
- source: '                //                // unindent members'
- source: '                //                string content = Input_Unindent(in_);'
- source: '                //                // check fail'
- source: '                //                if (content == "")'
- source: '                //                    return StreamFailed(in_);'
- source: '                //                // check end '
- source: '                //                if (content[content.size()-1] != ''\n'')'
- source: '                //                    return StreamFailed(in_);'
- source: '                //                // setup vars'
- source: '                //                char should_always_be_a_newline;'
- source: '                //                stringstream transfer_method;'
- source: '                //                // get rid of the class''s newline'
- source: '                //                transfer_method << content.substr(0,content.size()-1);'
- source: '                //            '
- source: '                //    '
- source: '                //        // create empty versions of all data members '
- source: '                //        datatype datamember;'
- source: '                //        input( transfer_method, datamember ); transfer_method.get(should_always_be_a_newline);'
- source: '                //            '
- source: '                //  '
- source: '                //                // if stream fails, then return fail '
- source: '                //                if (DidStreamFail(transfer_method))'
- source: '                //                    return StreamFailed(in_);'
- source: '                //            '
- source: '                // '
- source: '                // '
- source: '                //        // check the data, make sure its valid '
- source: '                //        if ( !IsDataValid(datamember)) '
- source: '                //            return StreamFailed(in_);'
- source: '                //'
- source: '                //        // add the data to the input '
- source: '                //        input_.data = datamember'
- source: '                //    '
- source: '                //                // if everything worked return the stream! '
- source: '                //                return in_;'
- source: '                //    }  '
- source: '            // bool IO        '
- source: '                ostream& output(ostream& out, const bool& input)'
- source: '                    {'
- source: '                        // name of class '
- source: '                        out << "bool" << ''\n'';'
- source: '                        // each data member in_ class'
- source: '                        if (input)'
- source: '                            out << Indent("true") << ''\n'';'
- source: '                        else '
- source: '                            out << Indent("false") << ''\n'';'
- source: '                        return out;'
- source: '                    }'
- source: '                istream& input (istream& in_,        bool& input)'
- source: '                        {'
- source: '                            // check name of type '
- source: '                            if ( EverythingUpTo(''\n'',in_) != "bool\n")'
- source: '                                return StreamFailed(in_);'
- source: '                            // unindent everything'
- source: '                            string content = Input_Unindent(in_);'
- source: '                            // check fail'
- source: '                            if (content == "")'
- source: '                                return StreamFailed(in_);'
- source: '                            // try to input data'
- source: '                            if      (content == "true\n")'
- source: '                                input = true;'
- source: '                            else if (content == "false\n")'
- source: '                                input = false;'
- source: '                            // if not true or false, then fail'
- source: '                            else '
- source: '                                return StreamFailed(in_);'
- source: '                            // if everything worked return the stream! '
- source: '                            return in_;'
- source: '                        }  '
- source: '            // char IO        '
- source: '                ostream& output(ostream& out, const char& input_char)'
- source: '                    {'
- source: '                        // name of class '
- source: '                        out << "char" << ''\n'';'
- source: '                        // each data member in_ class'
- source: '                        out << Indent(input_char) << ''\n'';'
- source: '                        return out;'
- source: '                    }'
- source: '                istream& input (istream& in_,        char& input_char)'
- source: '                        {'
- source: '                            // reset the char'
- source: '                            input_char = ''\0'';'
- source: '                            // check name of class '
- source: '                            if ( EverythingUpTo(''\n'',in_) != "char\n")'
- source: '                                return StreamFailed(in_);'
- source: '                            // unindent everything'
- source: '                            string char_content = Input_Unindent(in_);'
- source: '                            // check fail'
- source: '                            if (char_content == "")'
- source: '                                return StreamFailed(in_);'
- source: '                            // try to input data'
- source: '                            if (char_content.size() == 2)'
- source: '                                {'
- source: '                                    if (char_content[1] == ''\n'')'
- source: '                                        input_char = char_content[0];'
- source: '                                    else '
- source: '                                        return StreamFailed(in_);'
- source: '                                }'
- source: '                            else '
- source: '                                return StreamFailed(in_);'
- source: '                            // if everything worked return the stream! '
- source: '                            return in_;'
- source: '                        }'
- source: '            // int IO         '
- source: '                ostream& output(ostream& out, const int& input)'
- source: '                    {'
- source: '                        // name of class '
- source: '                        out << "integer" << ''\n'';'
- source: '                        // each data member in_ class'
- source: '                        out << Indent(input) << ''\n'';'
- source: '                        return out;'
- source: '                    }'
- source: '                istream& input (istream& in_,        int& input)'
- source: '                        {'
- source: '                            // check name of type '
- source: '                            if ( EverythingUpTo(''\n'',in_) != "integer\n")'
- source: '                                return StreamFailed(in_);'
- source: '                            // unindent everything'
- source: '                            string content = Input_Unindent(in_);'
- source: '                            // check fail'
- source: '                            if (content == "")'
- source: '                                return StreamFailed(in_);'
- source: '                            // try to input data'
- source: '                            stringstream content_as_stream;'
- source: '                            content_as_stream << content;'
- source: '                            char should_always_be_a_newline;'
- source: '                            content_as_stream >> input; '
- source: '                            content_as_stream.get(should_always_be_a_newline);'
- source: '                            // if failed somewhere, then return fail'
- source: '                            if (DidStreamFail(content_as_stream)) '
- source: '                                return StreamFailed(in_);'
- source: '                            // if everything worked return the stream! '
- source: '                            return in_;'
- source: '                        }            '
- source: '            // double IO      '
- source: '                ostream& output(ostream& out, const double& input)'
- source: '                    {'
- source: '                        // name of class '
- source: '                        out << "double" << ''\n'';'
- source: '                        // make sure and get all the decimals '
- source: '                        stringstream output;'
- source: '                        output << setprecision(20) << input;'
- source: '                        // each data member in_ class'
- source: '                        out << Indent(output.str()) << ''\n'';'
- source: '                        return out;'
- source: '                    }'
- source: '                istream& input (istream& in_,        double& input)'
- source: '                        {'
- source: '                            // check name of type '
- source: '                            if ( EverythingUpTo(''\n'',in_) != "double\n")'
- source: '                                return StreamFailed(in_);'
- source: '                            // unindent everything'
- source: '                            string content = Input_Unindent(in_);'
- source: '                            // check fail'
- source: '                            if (content == "")'
- source: '                                return StreamFailed(in_);'
- source: '                            // try to input data'
- source: '                            stringstream content_as_stream;'
- source: '                            content_as_stream << content;'
- source: '                            char should_always_be_a_newline;'
- source: '                            content_as_stream >> input; '
- source: '                            content_as_stream.get(should_always_be_a_newline);'
- source: '                            // if failed somewhere, then return fail'
- source: '                            if (DidStreamFail(content_as_stream)) '
- source: '                                return StreamFailed(in_);'
- source: '                            // if everything worked return the stream! '
- source: '                            return in_;'
- source: '                        }            '
- source: '            // long double IO '
- source: '                ostream& output(ostream& out, const long double& input)'
- source: '                    {'
- source: '                        // name of class '
- source: '                        out << "double" << ''\n'';'
- source: '                        // make sure and get all the decimals '
- source: '                        stringstream output;'
- source: '                        output << setprecision(20) << input;'
- source: '                        // each data member in_ class'
- source: '                        out << Indent(output.str()) << ''\n'';'
- source: '                        return out;'
- source: '                    }'
- source: '                istream& input (istream& in_,        long double& input)'
- source: '                        {'
- source: '                            // check name of type '
- source: '                            if ( EverythingUpTo(''\n'',in_) != "double\n")'
- source: '                                return StreamFailed(in_);'
- source: '                            // unindent everything'
- source: '                            string content = Input_Unindent(in_);'
- source: '                            // check fail'
- source: '                            if (content == "")'
- source: '                                return StreamFailed(in_);'
- source: '                            // try to input data'
- source: '                            stringstream content_as_stream;'
- source: '                            content_as_stream << content;'
- source: '                            char should_always_be_a_newline;'
- source: '                            content_as_stream >> input; '
- source: '                            content_as_stream.get(should_always_be_a_newline);'
- source: '                            // if failed somewhere, then return fail'
- source: '                            if (DidStreamFail(content_as_stream)) '
- source: '                                return StreamFailed(in_);'
- source: '                            // if everything worked return the stream! '
- source: '                            return in_;'
- source: '                        }            '
- source: '            // string IO      '
- source: '                ostream& output(ostream& out, const string& input)'
- source: '                    {'
- source: '                        // name of class '
- source: '                        out << "string" << ''\n'';'
- source: '                        // each data member in_ class'
- source: '                        out << Indent(input) << ''\n'';'
- source: '                        return out;'
- source: '                    }'
- source: '                istream& input (istream& in_,        string& input)'
- source: '                        {'
- source: '                            // check name of class '
- source: '                            if ( EverythingUpTo(''\n'',in_) != "string\n")'
- source: '                                return StreamFailed(in_);'
- source: '                            // unindent everything'
- source: '                            string content = Input_Unindent(in_);'
- source: '                            // check fail'
- source: '                            if (content == "")'
- source: '                                return StreamFailed(in_);'
- source: '                            // if it doesn''t end in_ newline, then fail'
- source: '                            if (content[content.size()-1] != ''\n'')'
- source: '                                return StreamFailed(in_);'
- source: '                            // try to input data'
- source: '                            input = content.substr(0,content.size()-1);'
- source: '                            // if everything worked return the stream! '
- source: '                            return in_;'
- source: '                        }                            '
- source: '                // c-string IO '
- source: '                ostream& output(ostream& out, const char input[])'
- source: '                    {'
- source: '                        // name of class '
- source: '                        out << "string" << ''\n'';'
- source: '                        // each data member in_ class'
- source: '                        out << Indent(input) << ''\n'';'
- source: '                        return out;'
- source: '                    } '
- source: '            // general IO     '
- source: '                template <class ANYTYPE> ostream& output(ostream& out, const ANYTYPE& input)'
- source: '                    {'
- source: '                         // name of class '
- source: '                        out << "default IO" << ''\n'';'
- source: '                        // each data member in_ class'
- source: '                        out << Indent(input) << ''\n'';'
- source: '                        return out;'
- source: '                    }'
- source: '                template <class ANYTYPE> istream& input (istream& in_,        ANYTYPE& input)'
- source: '                        {'
- source: '                            // check name of type '
- source: '                            if ( EverythingUpTo(''\n'',in_) != "default IO\n")'
- source: '                                return StreamFailed(in_);'
- source: '                            // unindent everything'
- source: '                            string content = Input_Unindent(in_);'
- source: '                            // check fail'
- source: '                            if (content == "")'
- source: '                                return StreamFailed(in_);'
- source: '                            // check end '
- source: '                            if (content[content.size()-1] != ''\n'')'
- source: '                                return StreamFailed(in_);'
- source: '                            // store data'
- source: '                            stringstream transfer_method;'
- source: '                            transfer_method << content.substr(0,content.size()-1);'
- source: '                            transfer_method >> input;'
- source: '                            // if stream fails, then return fail '
- source: '                            if (DidStreamFail(transfer_method))'
- source: '                                return StreamFailed(in_);'
- source: '                            // if everything worked return the stream! '
- source: '                            return in_;'
- source: '                        }              '
- source: '            // Conversion     '
- source: '                template <class ANYTYPE> string AsString(const ANYTYPE& input)'
- source: '                    {'
- source: '                        stringstream data_stream;'
- source: '                        output(data_stream, input);'
- source: '                        // get rid of the name '
- source: '                        EverythingUpTo(''\n'', data_stream);'
- source: '                        // get the content'
- source: '                        string content = Input_Unindent(data_stream);'
- source: '                        // remove the closing newline'
- source: '                        content = content.substr(0,content.size()-1);'
- source: '                        return content;'
- source: '                    }'
- source: '                template <class ANYTYPE> string TypeAsString(const ANYTYPE& input)'
- source: '                    {'
- source: '                        stringstream data_stream;'
- source: '                        output(data_stream, input);'
- source: '                        // get the name of the datatype'
- source: '                        string name = EverythingUpTo(''\n'', data_stream);'
- source: '                        // remove the closing newline'
- source: '                        name = name.substr(0,name.size()-1);'
- source: '                        return name;'
- source: '                    }'
- source: '        // VisualFormat basic types'
- source: '            // general VisualFormat'
- source: '                template<class ANYTYPE> // for most things just output via their << operator'
- source: '                string VisualFormat(ANYTYPE input)'
- source: '                {'
- source: '                    stringstream out;'
- source: '                    out << input;'
- source: '                    return out.str();'
- source: '                }'
- source: '            // bool   '
- source: '                string VisualFormat (bool   input)'
- source: '                    {'
- source: '                        string output;'
- source: '                        if (input == true)'
- source: '                            output = "true";'
- source: '                        else'
- source: '                            output = "false";'
- source: '                        return output;'
- source: '                    }'
- source: '            // char   '
- source: '                string VisualFormat (char   input)'
- source: '                    {'
- source: '                        return Literal(input);'
- source: '                    }'
- source: '            // int    '
- source: '                string VisualFormat (int    input)'
- source: '                    {'
- source: '                        return to_string(input);'
- source: '                    }'
- source: '            // double '
- source: '                string VisualFormat (double input)'
- source: '                    {'
- source: '                        return to_string(input);'
- source: '                    }'
- source: '            // string '
- source: '                string VisualFormat (string input)'
- source: '                    {'
- source: '                        return input;'
- source: '                    }'
- source: '            // Special Visual Formats '
- source: '                string          VisualFormatDollars        (double input)'
- source: '                    {'
- source: '                        stringstream output;'
- source: '                        output << fixed << setprecision(2);'
- source: '                        output << ''$'';'
- source: '                        output << input;'
- source: '                        return output.str();'
- source: '                    }'
- source: '        // Show'
- source: '            #define ThreadSafeCout(ARGS) {stringstream output; output << ARGS; cout << output.str(); };'
- source: '            template<class ANYTYPE> string Show(ANYTYPE input)'
- source: '                {'
- source: '                    cout << VisualFormat(input);'
- source: '                    return VisualFormat(input);'
- source: '                }'
- source: '        // Ask() basic types '
- source: '            string          Ask                        (string question_        )'
- source: '                {'
- source: '                    cout <<  question_ ; '
- source: '                    string Answer = "";'
- source: '                    Getline(cin, Answer);'
- source: '                    return Answer; '
- source: '                } '
- source: '            int             AskForAnInt                (string question_        )'
- source: '                {'
- source: '                    // this will match:'
- source: '                    // *spaces(or nothing)*   *a negative symbol(or nothing)*   *9 digits or less*    *spaces(or nothing)*'
- source: '                    regex  is_it_an_int("( *(-|)\\d{1,9} *)"); '
- source: '                    string answer_ = "";'
- source: '                    // loop until an integer is given'
- source: '                    while (true){'
- source: '                        answer_ = Ask(question_);'
- source: '                        // check if the input is actually an integer'
- source: '                        if ( regex_match(answer_, is_it_an_int) )'
- source: '                            return stoi(answer_);'
- source: '                        cout <<  "Sorry, but the input needs to be a (9 digits or less) positive integer\nplease try again"  << ''\n'';'
- source: '                        }'
- source: '                }'
- source: '            double          AskForANumber              (string question_        )'
- source: '                {'
- source: '                    // this will match:'
- source: '                    // *spaces(or nothing)*   *a negative symbol(or nothing)*   *9 digits or less*    *spaces(or nothing)*'
- source: '                    regex  is_it_a_number("( *(-|)(\\d{0,12}\\.\\d{1,12}|\\d{1,18}) *)"); '
- source: '                    string answer_ = "";'
- source: '                    // loop until an integer is given'
- source: '                    while (true){'
- source: '                        answer_ = Ask(question_);'
- source: '                        // check if the input is actually an integer'
- source: '                        if ( regex_match(answer_, is_it_a_number) )'
- source: '                            return stod(answer_);'
- source: '                        cout <<  "Sorry, but the input needs to a number (12 digits or less)\nplease try again"  << ''\n'';'
- source: '                        }'
- source: '                }'
- source: '            int             AskForAnIntFrom__To__      (string question_ , int smallest, int largest)'
- source: '                    {'
- source: '                        int integer_             = AskForAnInt( question_ );'
- source: '                        string internal_question = "Sorry, please just enter a number from " + to_string(smallest) + " to " + to_string(largest) + " \n";'
- source: '                        // keep asking the internal question until a valid number is given'
- source: '                        while (true){  '
- source: '                            if ( (integer_ >= smallest) && (integer_ <= largest) ) {'
- source: '                                break; '
- source: '                            }  '
- source: '                            integer_ = AskForAnInt( internal_question );'
- source: '                            }'
- source: '                        return integer_;'
- source: '                    }'
- source: '            double          AskForADoubleFrom__To__    (string question_ , double smallest, double largest)'
- source: '                    {'
- source: '                        double number_             = AskForANumber( question_ );'
- source: '                        string internal_question = "Sorry, please enter a number from " + to_string(smallest) + " to " + to_string(largest) + " \n";'
- source: '                        // keep asking the internal question until a valid number is given'
- source: '                        while (true){  '
- source: '                            if ( (number_ >= smallest) && (number_ <= largest) ) {'
- source: '                                break; '
- source: '                            }  '
- source: '                            number_ = AskForANumber( internal_question );'
- source: '                            }'
- source: '                        return number_;'
- source: '                    }'
- source: '            bool            AskYesOrNo                 (string question_) '
- source: '                    {'
- source: '                        while (true){'
- source: '                            // FIXME use regex here instead'
- source: '                            string answer_ = Ask(question_);'
- source: '                            if (          ( answer_ == "yes" || answer_ == "Yes" || answer_ == "y" || answer_ == "Y" ) ) {'
- source: '                                return true;'
- source: '                            } else if ( ( answer_ == "no"  || answer_ == "No"  || answer_ == "n" || answer_ == "N" ) ) {'
- source: '                                return false;'
- source: '                            }  '
- source: '                            cout <<  "Sorry I don''t understand your input :/"      << ''\n''; '
- source: '                            cout <<  "Use ''yes'' and ''no'' and try avoiding spaces"  << ''\n'';'
- source: '                            }'
- source: '                    }'
- source: '            string          AskForAFileName            (string question_)'
- source: '                    {'
- source: '                        while (true){'
- source: '                                string file_name = Ask( question_ );'
- source: '                                if ( IsALegitFileName(file_name) ) {'
- source: '                                    return file_name; '
- source: '                                } '
- source: '                                // else '
- source: '                                cout <<  "Sorry, please only use letter, numbers, and underscores in_ the name\n";'
- source: '                            }'
- source: '                    }'
- source: '            fstream         AskUserForExistingFile     (string question_)'
- source: '                    {'
- source: '                        while (true){'
- source: '                                string name_ = AskForAFileName( question_ );'
- source: '                                fstream the_file(name_);'
- source: '                                if ( static_cast<bool>(the_file) ) {'
- source: '                                    return the_file;'
- source: '                                } '
- source: '                                cout <<  "Sorry I dont see that file, please enter another file name\n";'
- source: '                            } '
- source: '                    }'
- source: '        // File IO  '
- source: '            template <class ANYTYPE> void    Save__In__     (ANYTYPE  data_to_save, string file_location)'
- source: '                    {'
- source: '                        ofstream the_file_stream(file_location);'
- source: '                        output(the_file_stream, data_to_save);'
- source: '                        the_file_stream.close();'
- source: '                    }'
- source: '            template <class ANYTYPE> void    Load__From__   (ANYTYPE& data_to_load, string file_location)'
- source: '                    {'
- source: '                        ifstream the_file_stream(file_location);'
- source: '                        input(the_file_stream, data_to_load);'
- source: '                        the_file_stream.close();'
- source: '                    }'
- source: '            void SaveFile(string file_location, string content)'
- source: '                {'
- source: '                    ofstream the_file_stream(file_location);'
- source: '                    the_file_stream << content;'
- source: '                    the_file_stream.close();'
- source: '                }'
- source: '            string ReadFile(string file_location)'
- source: '                {'
- source: '                    ifstream the_file(file_location);'
- source: '                    string content( (istreambuf_iterator<char>(the_file) ), istreambuf_iterator<char>());'
- source: '                    the_file.close();'
- source: '                    return content;'
- source: '                }'
- source: '            string  OpenFileAsString           (string file_location)'
- source: '                {'
- source: '                    fstream the_file(file_location);'
- source: '                    if ( static_cast<bool>(the_file) ) {'
- source: '                        return ReadFile(file_location);'
- source: '                    } '
- source: '                    Error( "Sorry I dont see that file, please enter another file name\n");'
- source: '                }'
- source: '        // Threads'
- source: '            // '
- source: '            // This is a function that is given to '
- source: '            // '
- source: '            void* thread_stub(void* context)'
- source: '                {'
- source: '                    // context is static_cast<void*>(&f) below. We reverse the cast to'
- source: '                    // void* and call the function object.'
- source: '                    function<void*()>& func = *static_cast<function<void*()>*>(context);'
- source: '                    return func();'
- source: '                }'
- source: '            template <class ANY_OUTPUT_TYPE, class ANY_INPUT_TYPE>'
- source: '            class TaskClass '
- source: '                {'
- source: '                // summary/explaination'
- source: '                    // What is this used for?'
- source: '                        // if you want to run a function on a thread, and you don''t want any segfaults'
- source: '                        // this class makes input/output for threaded functions easy'
- source: '                        // this class makes sure the arguments exist for the whole time that the thread exists (very importatnt)'
- source: '                        // this class works with lambdas as well as normal functions'
- source: '                    // How do I use it?'
- source: '                        // auto immaFunction = function<int(string)>([&](string input_string)'
- source: '                        //     {'
- source: '                        //          cout << "I received this as an argument " << input_string << "\n"; '
- source: '                        //          return 69;'
- source: '                        //     }'
- source: '                        // string the_input = "Hello World";'
- source: '                        // auto a_task = Task(immaFunction, the_input);'
- source: '                        // int output_of_task = a_task.WaitForCompletion();'
- source: '                    // Caveats'
- source: '                        // The argument must have a copy constructor and a default (empty) constructor'
- source: '                        // If the class you''re using doesn''t have those, then pass a pointer, or create a wrapper class that does have those'
- source: '                    // How does it work?'
- source: '                        // this class essentially contains '
- source: '                            // 1. a function '
- source: '                            // 2. a copy of the arguments for that function '
- source: '                            // 3. the output of the function'
- source: '                            // 4. a thread id for the thread the function is being run on'
- source: '                        // it wraps the functions it''s given and then passes the wrapper function to the thread'
- source: '                public:'
- source: '                    // Data'
- source: '                        pthread_t thread;'
- source: '                        ANY_OUTPUT_TYPE (*thread_function)(ANY_INPUT_TYPE argument);'
- source: '                        function<ANY_OUTPUT_TYPE(ANY_INPUT_TYPE argument)> lambda_thread_function;'
- source: '                        function<void*()> functional_wrapper;'
- source: '                        ANY_OUTPUT_TYPE output;'
- source: '                        ANY_INPUT_TYPE arguments;'
- source: '                        bool use_lambda = false;'
- source: '                        bool has_been_waited_on = true; // by deafult the task is ready to start'
- source: '                    // Constructors'
- source: '                        TaskClass(const TaskClass &obj)'
- source: '                            {'
- source: '                                Error("Something somewhere is trying to copy a TaskClass() object. Sadly copying a TaskClass is not yet possible.\nThis is likely happening when trying to add a task to a vector or some similar operation.\nThis can often be fixed by using a TaskClass pointer instead");'
- source: '                            }'
- source: '                        TaskClass(function<ANY_OUTPUT_TYPE(ANY_INPUT_TYPE argument)> input_function, ANY_INPUT_TYPE input_arguments)'
- source: '                            {'
- source: '                                use_lambda = true;'
- source: '                                lambda_thread_function = input_function;'
- source: '                                arguments = input_arguments;'
- source: '                            }'
- source: '                        TaskClass(ANY_OUTPUT_TYPE (*input_function)(ANY_INPUT_TYPE argument))'
- source: '                            {'
- source: '                                thread_function = input_function;'
- source: '                            }'
- source: '                        TaskClass(ANY_OUTPUT_TYPE (*input_function)(ANY_INPUT_TYPE argument), ANY_INPUT_TYPE input_arguments)'
- source: '                            {'
- source: '                                thread_function = input_function;'
- source: '                                arguments = ANY_INPUT_TYPE(input_arguments);'
- source: '                            }'
- source: '                    // Methods'
- source: '                        void Start(const pthread_attr_t* attributes=NULL)'
- source: '                            {'
- source: '                                // if its possible the task is still running'
- source: '                                if (has_been_waited_on == false) '
- source: '                                    {'
- source: '                                        cout << "for task with address = " << this << "\n";'
- source: '                                        cout << "I think you''re trying to start this task but it hasn''t been waited on yet.\n";'
- source: '                                        cout << "either do the_task.WaitForCompletion() before trying to restart this task, or create a seperate task object\n";'
- source: '                                        return;'
- source: '                                    }'
- source: '                                // if the task wasnt running before, it is now'
- source: '                                has_been_waited_on = false;'
- source: '                                functional_wrapper = function<void*()>([&]() mutable -> void* {'
- source: '                                        // give the input arguments (stored on the the task object) to the function'
- source: '                                        // and save the output to the task object'
- source: '                                        if (use_lambda)'
- source: '                                            {'
- source: '                                                output = lambda_thread_function(arguments);'
- source: '                                            }'
- source: '                                        else'
- source: '                                            {'
- source: '                                                output = thread_function(arguments);'
- source: '                                            }'
- source: '                                        has_been_waited_on = true;'
- source: '                                        pthread_exit(NULL);'
- source: '                                        return NULL;'
- source: '                                    });'
- source: '                                pthread_create(&thread, attributes, thread_stub, &functional_wrapper);'
- source: '                            }'
- source: '                        ANY_OUTPUT_TYPE WaitForCompletion()'
- source: '                            {'
- source: '                                // wait for the thread to finish'
- source: '                                pthread_join(thread, NULL);'
- source: '                                // this task is no longer running'
- source: '                                has_been_waited_on = true;'
- source: '                                // return the output'
- source: '                                return output;'
- source: '                            }'
- source: '                };'
- source: '            pthread_t __dummy_thread;'
- source: '            template <class ANY_OUTPUT_TYPE, class ANY_INPUT_TYPE>'
- source: '            class Task'
- source: '                {'
- source: '                // summary/explaination:'
- source: '                    // This is just a wrapper for a TaskClass pointer'
- source: '                    // it is created so that copies (shallow copies) can be made without breaking everything and causing a segfault'
- source: '                    // it keeps track of how many shallow copies there are for a proticular task and once the last shallow copy is destroyed it deletes the original TaskClass obj/pointer to prevent memoryleaks'
- source: '                public:'
- source: '                    // data'
- source: '                        static map<TaskClass<ANY_OUTPUT_TYPE, ANY_INPUT_TYPE>*, int> links_to;'
- source: '                        TaskClass<ANY_OUTPUT_TYPE, ANY_INPUT_TYPE>* ptr_to_original = nullptr;'
- source: '                        pthread_t& thread;'
- source: '                    // constructors'
- source: '                        Task() : thread(__dummy_thread)'
- source: '                            {'
- source: '                            }'
- source: '                        Task(TaskClass<ANY_OUTPUT_TYPE, ANY_INPUT_TYPE>* a_task_ptr) : thread(__dummy_thread)'
- source: '                            {'
- source: '                                ptr_to_original = a_task_ptr;'
- source: '                                // if no links'
- source: '                                if (links_to.find(ptr_to_original) == links_to.end())'
- source: '                                    {'
- source: '                                        // then set the initial number of links to 0'
- source: '                                        links_to[ptr_to_original] = 0;'
- source: '                                    }'
- source: '                                // add one link'
- source: '                                ++links_to[ptr_to_original];'
- source: '                                thread = a_task_ptr->thread;'
- source: '                            }'
- source: '                        Task(const Task &obj) : thread(__dummy_thread)'
- source: '                            {'
- source: '                                ptr_to_original = obj.ptr_to_original;'
- source: '                                thread = obj.ptr_to_original->thread;'
- source: '                                // if no links'
- source: '                                if (links_to.find(ptr_to_original) == links_to.end())'
- source: '                                    {'
- source: '                                        // then set the initial number of links to 0'
- source: '                                        links_to[ptr_to_original] = 0;'
- source: '                                    }'
- source: '                                // add one link'
- source: '                                ++links_to[ptr_to_original];'
- source: '                            }'
- source: '                        ~Task()'
- source: '                            {'
- source: '                                // decrement one link'
- source: '                                --links_to[ptr_to_original];'
- source: '                                // if no links, then delete'
- source: '                                if (links_to[ptr_to_original] == 0)'
- source: '                                    {'
- source: '                                        delete ptr_to_original;'
- source: '                                    }'
- source: '                            }'
- source: '                    // methods'
- source: '                        void SetOriginal(TaskClass<ANY_OUTPUT_TYPE, ANY_INPUT_TYPE>* a_pointer)'
- source: '                            {'
- source: '                                ptr_to_original = a_pointer;'
- source: '                                ++links_to[ptr_to_original];'
- source: '                                thread = &(a_pointer->thread);'
- source: '                            }'
- source: '                        void Start(const pthread_attr_t* attributes=NULL)'
- source: '                            {'
- source: '                                if (ptr_to_original == nullptr)'
- source: '                                    {'
- source: '                                        ThreadSafeCout("You''re tring to start a Task object, but its pointer points to nullptr\nThe address of the object is: " << this << "\n");'
- source: '                                    }'
- source: '                                else'
- source: '                                    {'
- source: '                                        ptr_to_original->Start();'
- source: '                                    }'
- source: '                            }'
- source: '                        ANY_OUTPUT_TYPE WaitForCompletion()'
- source: '                            {'
- source: '                                return ptr_to_original->WaitForCompletion();'
- source: '                            }'
- source: '                        bool StillRunning()'
- source: '                            {'
- source: '                                return not ptr_to_original->has_been_waited_on;'
- source: '                            }'
- source: '                    // operators'
- source: '                        Task& operator=( const Task& obj )'
- source: '                            {'
- source: '                                ptr_to_original = obj.ptr_to_original;'
- source: '                                thread = obj.ptr_to_original->thread;'
- source: '                                // if no links'
- source: '                                if (links_to.find(ptr_to_original) == links_to.end())'
- source: '                                    {'
- source: '                                        // then set the initial number of links to 0'
- source: '                                        links_to[ptr_to_original] = 0;'
- source: '                                    }'
- source: '                                // add one link'
- source: '                                ++links_to[ptr_to_original];'
- source: '                                return this;'
- source: '                            }'
- source: '                };'
- source: '            template <class ANY_OUTPUT_TYPE, class ANY_INPUT_TYPE> map<TaskClass<ANY_OUTPUT_TYPE, ANY_INPUT_TYPE>*, int> Task<ANY_OUTPUT_TYPE, ANY_INPUT_TYPE>::links_to;'
- source: '            // have the TaskClass automatically detect the argument and return type'
- source: '            #define Task(FUNC, ARG) Task<decltype(FUNC(decltype(ARG){})), decltype(ARG)>(new TaskClass<decltype(FUNC(decltype(ARG){})), decltype(ARG)>(FUNC, ARG));'
- source: '                // Helpers'
- source: '                void* WaitFor(pthread_t thread)'
- source: '                    {'
- source: '                        void * _Nullable * _Nullable output = NULL;'
- source: '                        pthread_join(thread, output);'
- source: '                        return (void*)output;'
- source: '                    }'
- source: '            class LockManagerClass'
- source: '                {'
- source: '                public:'
- source: '                    // data'
- source: '                        map<void*, pthread_mutex_t> map_of_locks;'
- source: '                    // methods'
- source: '                        void Lock(void* varaible_address)'
- source: '                            {'
- source: '                                // if there isn''t a mutex for the address, then make one'
- source: '                                if (map_of_locks.find(varaible_address) == map_of_locks.end())'
- source: '                                    {'
- source: '                                        // make a mutex'
- source: '                                        map_of_locks[varaible_address] = PTHREAD_MUTEX_INITIALIZER;'
- source: '                                    }'
- source: '                                // lock the mutex'
- source: '                                pthread_mutex_lock(&(map_of_locks[varaible_address]));'
- source: '                            }'
- source: '                        void Unlock(void* varaible_address)'
- source: '                            {'
- source: '                                // If there isn''t a mutex for the var, then do nothing'
- source: '                                if (map_of_locks.find(varaible_address) == map_of_locks.end())'
- source: '                                    {'
- source: '                                        return;'
- source: '                                    }'
- source: '                                // unlock the mutex '
- source: '                                else'
- source: '                                    {'
- source: '                                        pthread_mutex_unlock(&(map_of_locks[varaible_address]));'
- source: '                                    }'
- source: '                            }'
- source: "                }\_LockManager;"
- source: "                #define Lock(ARGS)\_LockManager.Lock((void*)(&ARGS))"
- source: "                #define Unlock(ARGS)\_LockManager.Unlock((void*)(&ARGS))"
- source: //////////////////////
- source: //
- source: // Secondary helper functions
- source: //
- source: //////////////////////
- source: '    // Vector functions '
- source: '        // IO           '
- source: '            template <class    ANYTYPE> ostream&   output   (ostream& out, const vector<ANYTYPE>& input_vector)'
- source: '                {'
- source: '                    bool local_debug = false;'
- source: '                    // name of class '
- source: '                    out << "vector" << ''\n'';'
- source: '                    // each data member in_ class'
- source: '                    stringstream all_members;'
- source: '                    for ( ANYTYPE each : input_vector ) '
- source: '                        { '
- source: '                            output(all_members, each);'
- source: '                            all_members << ''\n'';'
- source: '                        }'
- source: '                    // if no data members'
- source: '                    if (input_vector.size() == 0)'
- source: '                        all_members << "\n";'
- source: '                    // Indent the whole thing'
- source: '                    if (local_debug) cout << "all_members is " << Literal(all_members.str()) << "\n";'
- source: '                    string all_members_str = all_members.str();'
- source: '                    out << Indent(all_members_str) << ''\n'';'
- source: '                    return out;'
- source: '                }'
- source: '            template <class    ANYTYPE> istream&   input    (istream& in_, vector<ANYTYPE>& input_vector)'
- source: '                {'
- source: '                    bool local_debug = true;'
- source: '                    // reset the input vector'
- source: '                    input_vector = {};'
- source: '                    // check name of class '
- source: '                    if ( EverythingUpTo(''\n'',in_) != "vector\n")'
- source: '                        return StreamFailed(in_);'
- source: '                    // unindent everything'
- source: '                    string vector_content = Input_Unindent(in_);'
- source: '                    if (local_debug) cout << "vector content:\n";'
- source: '                    if (local_debug) cout << Literal(vector_content) << ''\n'';'
- source: '                    // check fail'
- source: '                    if (vector_content == "")'
- source: '                        return StreamFailed(in_);'
- source: '                    // check no members'
- source: '                    if ( vector_content == "\n" )'
- source: '                        return in_;'
- source: '                    // try to input data'
- source: '                    ANYTYPE data_member;'
- source: '                    stringstream vector_content_as_stream;'
- source: '                    vector_content_as_stream << vector_content;'
- source: '                    char should_always_be_a_newline;'
- source: '                    // try inputting data members till EOF '
- source: '                    do '
- source: '                        {'
- source: '                            input(vector_content_as_stream, data_member);'
- source: '                            vector_content_as_stream.get(should_always_be_a_newline);'
- source: '                            if ( DidStreamFail(vector_content_as_stream) )'
- source: '                                {'
- source: '                                    return StreamFailed(in_);'
- source: '                                }'
- source: '                            input_vector.push_back(data_member);'
- source: '                        } while(not EndOfStream(vector_content_as_stream) );'
- source: '                    // if no data members were added, report an error'
- source: '                    if (input_vector.size() == 0)'
- source: '                        return StreamFailed(in_);'
- source: '                    // if everything worked return the stream! '
- source: '                    return in_;'
- source: '                }'
- source: '        // VisualFormat '
- source: '            template <class    ANYTYPE> string          VisualFormat                  (vector<ANYTYPE> input)'
- source: '                {'
- source: '                    stringstream output;'
- source: '                    for ( ANYTYPE each : input ) '
- source: '                        {'
- source: '                            output << VisualFormat(each) << ''\n'';'
- source: '                        }'
- source: '                    return Indent(output.str());'
- source: '                }'
- source: '        // helpers      '
- source: '            template <class    ANYTYPE> void            Remove__ThElementFrom__Vector (int element_number  , vector<ANYTYPE>& input_vector ) '
- source: '                { '
- source: '                    input_vector.erase(input_vector.begin() + element_number);'
- source: '                } '
- source: '            template <class    ANYTYPE> bool            Is__In__Vector                (ANYTYPE test_val    , vector<ANYTYPE>& input_vector ) '
- source: '                { '
- source: '                    for (auto each : input_vector)'
- source: '                        {'
- source: '                            if (each == test_val)'
- source: '                                {'
- source: '                                    return true;'
- source: '                                }'
- source: '                        }'
- source: '                } '
- source: '            template <class    ANYTYPE> bool            Is__In__                      (ANYTYPE test_val    , vector<ANYTYPE>& input_vector ) '
- source: '                { '
- source: '                    { int Max_Value =  input_vector .size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { int EachItem = LoopNumber - 1; '
- source: '                        if ( input_vector.at( EachItem ) == test_val ) { '
- source: '                            return true ;'
- source: '                        } '
- source: '                    } } '
- source: '                    return false ; '
- source: '                } '
- source: '            template <class    ANYTYPE> int             IndexOf__In__Vector           (ANYTYPE test_val    , vector<ANYTYPE>& input_vector ) '
- source: '                { '
- source: '                    { int Max_Value =  input_vector .size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { int EachItem = LoopNumber - 1; '
- source: '                        if ( (input_vector.at( EachItem ) == test_val) ) { '
- source: '                            return EachItem;'
- source: '                        } '
- source: '                    } } '
- source: '                    return -1; '
- source: '                } '
- source: '            template <class    ANYTYPE> void            RemoveFirst__From__Vector     (ANYTYPE element_    , vector<ANYTYPE>& input_vector ) '
- source: '                { '
- source: '                    int element_number = IndexOf__In__Vector(element_ , input_vector);'
- source: '                    input_vector.erase(input_vector.begin() + element_number);'
- source: '                } '
- source: '            template <class    ANYTYPE> int             NumberOf__In__Vector          (ANYTYPE test_val    , vector<ANYTYPE>& input_vector ) '
- source: '                { '
- source: '                    int number_of_matches;'
- source: '                    { int Max_Value =  input_vector .size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { int EachItem = LoopNumber - 1; '
- source: '                        if ( input_vector.at( EachItem ) == test_val ) { '
- source: '                            number_of_matches++;'
- source: '                        } '
- source: '                    } } '
- source: '                    return number_of_matches; '
- source: '                } '
- source: '            template <class    ANYTYPE> vector<ANYTYPE> RemoveDuplicates              (                      vector<ANYTYPE>& input_vector ) '
- source: '                { '
- source: '                    vector<ANYTYPE> search_vector; '
- source: '                    { int Max_Value =  input_vector .size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { int EachItem = LoopNumber - 1; '
- source: '                            if ( Is__In__Vector( input_vector.at(EachItem) , search_vector ) ) {'
- source: '                                Remove__ThElementFrom__Vector(EachItem, input_vector);'
- source: '                            } else {'
- source: '                                search_vector.push_back( input_vector.at(EachItem) );'
- source: '                            }  '
- source: '                    } } '
- source: '                }'
- source: '            char**                                      VectorStringToCStringArray    (vector<string>& input)'
- source: '                {'
- source: '                    // NOTE if you dont delete the output manually, there will be a memory leak'
- source: '                    // find largest string'
- source: '                    int largest_string = 0;'
- source: '                    for (auto each : input)'
- source: '                        {'
- source: '                            largest_string = each.size() > largest_string ? each.size() : largest_string;'
- source: '                        }'
- source: '                    // create a vector of c-strings'
- source: '                    vector<char*> vector_of_c_strings;'
- source: '                    for (auto each : input)'
- source: '                        {'
- source: '                            char* new_string = new char[each.size()];'
- source: '                            strcpy(new_string, each.c_str());'
- source: '                            vector_of_c_strings.push_back(new_string);'
- source: '                        }'
- source: '                    // terminate it with a null pointer'
- source: '                    vector_of_c_strings.push_back(NULL);'
- source: '                    // create the array'
- source: '                    char** output = new char*[vector_of_c_strings.size()];'
- source: '                    copy(vector_of_c_strings.begin(), vector_of_c_strings.end(), output);'
- source: '                    return output;'
- source: '                }'
- source: '            template <typename T> vector<T>   Slice     (vector<T> base, int start, int finish)'
- source: '                {'
- source: '                    vector<T> result;'
- source: '                    if (start < 0)'
- source: '                        start = base.size() + start;'
- source: '                    else if (start > base.size())'
- source: '                        start = base.size();'
- source: '                    if (finish < 0)'
- source: '                        finish = base.size() + finish;'
- source: '                    else if (finish > base.size())'
- source: '                        finish = base.size();'
- source: '                    if (start > finish) {'
- source: '                        int swap = start;'
- source: '                        start = finish;'
- source: '                        finish = swap;'
- source: '                    }'
- source: '                    for (int i = start; i < finish; i++)'
- source: '                        result.push_back(base[i]);'
- source: '                    return result;'
- source: '                }'
- source: '            template <typename T> vector<T>   Slice     (vector<T> base, int start)'
- source: '                {'
- source: '                    return Slice(start, base.size());'
- source: '                }'
- source: '            template <typename T> vector<T>   Splice    (vector<T> base, int start, int count, vector<T> additions)'
- source: '                {'
- source: '                    vector<T> result;'
- source: '                    if (start < 0)'
- source: '                        start = base.size() + start;'
- source: '                    else if (start > base.size())'
- source: '                        start = base.size();'
- source: '                    if (count > base.size() - start)'
- source: '                        count = base.size() - start;'
- source: '                    for (int i = 0; i < start; i++)'
- source: '                        result.push_back(base[i]);'
- source: '                    for (int i = 0; i < additions.size(); i++)'
- source: '                        result.push_back(additions[i]);'
- source: '                    for (int i = start + count; i < base.size(); i++)'
- source: '                        result.push_back(base[i]);'
- source: '                    return result;'
- source: '                }'
- source: '            template <typename T> vector<T>   Splice    (vector<T> base, int start, int count)'
- source: '                {'
- source: '                    vector<T> empty;'
- source: '                    return Splice(base, start, count, empty);'
- source: '                }'
- source: '            template <typename T> vector<T>   Splice    (vector<T> base, int start, vector<T> additions)'
- source: '                {'
- source: '                    return Splice(base, start, 0, additions);'
- source: '                }'
- source: '            template <typename T> int         Index     (vector<T> base, T target)'
- source: '                {'
- source: '                    int index = 0;'
- source: '                    while (index < base.size()) {'
- source: '                        if (base[index] == target)'
- source: '                            return index;'
- source: '                        index++;'
- source: '                    }'
- source: '                    return -1;'
- source: '                }'
- source: '            template <typename T> int         LastIndex (vector<T> base, T target)'
- source: '                {'
- source: '                    int index = base.size();'
- source: '                    while (index) {'
- source: '                        if (base[index] == target)'
- source: '                            return index;'
- source: '                        index--;'
- source: '                    }'
- source: '                    return -1;'
- source: '                }'
- source: '            template <typename T> vector<int> Indices   (vector<T> base, T target)'
- source: '                {'
- source: '                    vector<int> indices;'
- source: '                    int index = 0;'
- source: '                    while (index < base.size()) {'
- source: '                        if (base[index] == target)'
- source: '                            indices.push_back(index);'
- source: '                        index++;'
- source: '                    }'
- source: '                    return indices;'
- source: '                }'
- source: '            template <typename T> bool        Includes  (vector<T> base, T target)'
- source: '                {'
- source: '                    return (Index(base, target) > -1);'
- source: '                }'
- source: '    // Map functions'
- source: '        // IO           '
- source: '            // Pairs '
- source: '                template <class ANYTYPE, class ANYSECONDTYPE> ostream& output (ostream& out, const pair<ANYTYPE,ANYSECONDTYPE>& input_)'
- source: '                    {'
- source: '                        bool local_debug = false;'
- source: '                        // name of class '
- source: '                        out << "pair" << ''\n'';'
- source: '                        stringstream all_members;'
- source: '                        // each data member in_ class'
- source: '                        output(all_members, input_.first ); all_members << ''\n'';'
- source: '                        output(all_members, input_.second); all_members << ''\n'';'
- source: '                        // Indent the whole thing'
- source: '                        if (local_debug) cout << "all_members is " << Literal(all_members.str()) << "\n";'
- source: '                        string all_members_str = all_members.str();'
- source: '                        out << Indent(all_members_str) << ''\n'';'
- source: '                        return out;'
- source: '                    }'
- source: '                template <class ANYTYPE, class ANYSECONDTYPE> istream& input  (istream& in_,        pair<ANYTYPE,ANYSECONDTYPE>& input_)'
- source: '                    {'
- source: '                        // check name of type '
- source: '                        if ( EverythingUpTo(''\n'',in_) != "pair\n")'
- source: '                            return StreamFailed(in_);'
- source: '                                // unindent members'
- source: '                                string content = Input_Unindent(in_);'
- source: '                                // check fail'
- source: '                                if (content == "")'
- source: '                                    return StreamFailed(in_);'
- source: '                                // check end '
- source: '                                if (content[content.size()-1] != ''\n'')'
- source: '                                    return StreamFailed(in_);'
- source: '                                // setup vars'
- source: '                                char should_always_be_a_newline;'
- source: '                                stringstream transfer_method;'
- source: '                                // get rid of the class''s newline'
- source: '                                transfer_method << content.substr(0,content.size()-1);'
- source: '                        // create empty versions of all data members '
- source: '                        ANYTYPE  datamember1;'
- source: '                        ANYSECONDTYPE datamember2;'
- source: '                        input( transfer_method, datamember1 ); transfer_method.get(should_always_be_a_newline);'
- source: '                        input( transfer_method, datamember2 ); transfer_method.get(should_always_be_a_newline);'
- source: '                                // if stream fails, then return fail '
- source: '                                if (DidStreamFail(transfer_method))'
- source: '                                    return StreamFailed(in_);'
- source: '                        // add the data to the input '
- source: '                        input_.first  = datamember1;'
- source: '                        input_.second = datamember2;'
- source: '                                // if everything worked return the stream! '
- source: '                                return in_;'
- source: '                    }'
- source: '            // Maps  '
- source: '                template <class ANYTYPE, class ANYSECONDTYPE> ostream& output (ostream& out, const map<ANYTYPE,ANYSECONDTYPE>& input_)'
- source: '                    {'
- source: '                        // name of class '
- source: '                        out << "map" << ''\n'';'
- source: '                                stringstream data_members;'
- source: '                        // for each datamember'
- source: '                        for ( pair<ANYTYPE,ANYSECONDTYPE> each : input_ ) '
- source: '                            { '
- source: '                                output(data_members, each); data_members << ''\n'';'
- source: '                            }'
- source: '                                // format and return stream'
- source: '                                out << Indent( data_members.str() ) << ''\n'';'
- source: '                                return out;'
- source: '                    }'
- source: '                template <class ANYTYPE, class ANYSECONDTYPE> istream& input  (istream& in_,        map<ANYTYPE,ANYSECONDTYPE>& input_)'
- source: '                    {'
- source: '                        // check name of type '
- source: '                        if ( EverythingUpTo(''\n'',in_) != "map\n")'
- source: '                            return StreamFailed(in_);'
- source: '                                // unindent members'
- source: '                                string content = Input_Unindent(in_);'
- source: '                                // check fail'
- source: '                                if (content == "")'
- source: '                                    return StreamFailed(in_);'
- source: '                                // check end '
- source: '                                if (content[content.size()-1] != ''\n'')'
- source: '                                    return StreamFailed(in_);'
- source: '                                // setup vars'
- source: '                                char should_always_be_a_newline;'
- source: '                                stringstream transfer_method;'
- source: '                                // get rid of the class''s newline'
- source: '                                transfer_method << content.substr(0,content.size()-1);'
- source: '                        // check for no members'
- source: '                        if ( content == "\n" )'
- source: '                            return in_;'
- source: '                        // try to input data'
- source: '                        pair<ANYTYPE,ANYSECONDTYPE> data_member;'
- source: '                        map<ANYTYPE,ANYSECONDTYPE>  data_member_holder;'
- source: '                        // try inputting data members till EOF '
- source: '                        do '
- source: '                            {'
- source: '                                input(transfer_method, data_member);'
- source: '                                transfer_method.get(should_always_be_a_newline);'
- source: '                                if ( DidStreamFail(transfer_method) )'
- source: '                                    {'
- source: '                                        return StreamFailed(in_);'
- source: '                                    }'
- source: '                                data_member_holder[data_member.first] = data_member.second;'
- source: '                            } while(not EndOfStream(transfer_method) );        '
- source: '                        // add the data to the input '
- source: '                        input_ = data_member_holder;'
- source: '                                // if everything worked return the stream! '
- source: '                                return in_;'
- source: '                    }  '
- source: '        // VisualFormat '
- source: '        // helpers      '
- source: '            template <class ANYTYPE, class ANYSECONDTYPE> bool   Is__KeyIn__Map   (ANYTYPE key,   map<ANYTYPE,       ANYSECONDTYPE> input_map)'
- source: '                {'
- source: '                    // maps      http://www.cprogramming.com/tutorial/stl/stlmap.html'
- source: '                    if(input_map.find(key) == input_map.end())'
- source: '                        return false;'
- source: '                    return true;'
- source: '                }'
- source: '            template <class ANYTYPE, class ANYSECONDTYPE> bool   Is__ValueIn__Map (ANYTYPE value, map<ANYSECONDTYPE, ANYTYPE      > input_map)'
- source: '                {'
- source: '                    // maps     http://stackoverflow.com/questions/26281979/c-loop-through-map'
- source: '                    for( auto const& each : input_map )'
- source: '                        {'
- source: '                            if (each.second == value)'
- source: '                                {'
- source: '                                    return true;'
- source: '                                }'
- source: '                        }'
- source: '                    return false;'
- source: '                }'
- source: '            template <class ANYTYPE, class ANYSECONDTYPE> ANYSECONDTYPE KeyOfFirst__ValueIn__Map (ANYTYPE value, map<ANYSECONDTYPE, ANYTYPE      > input_map)'
- source: '                {'
- source: '                    // maps     http://stackoverflow.com/questions/26281979/c-loop-through-map'
- source: '                    for( auto const& each : input_map )'
- source: '                        {'
- source: '                            if (each.second == value)'
- source: '                                {'
- source: '                                    return each.first;'
- source: '                                }'
- source: '                        }'
- source: '                    ANYSECONDTYPE null_;'
- source: '                    return null_;'
- source: '                }'
- source: '            template <class ANYTYPE                     > bool   Is__In__         (ANYTYPE value,   map<ANYTYPE, ANYTYPE> input_map)'
- source: '                    {'
- source: '                        if (Is__KeyIn__Map(value, input_map))'
- source: '                            return true;'
- source: '                        if (Is__ValueIn__Map(value, input_map))'
- source: '                            return true;'
- source: '                        return false;'
- source: '                    }'
- source: '            template <class ANYTYPE, class ANYSECONDTYPE> bool   Is__In__         (ANYTYPE value,   map<ANYTYPE, ANYSECONDTYPE> input_map)'
- source: '                    {'
- source: '                        if (Is__KeyIn__Map(value, input_map))'
- source: '                            return true;'
- source: '                    }'
- source: '            template <class ANYTYPE, class ANYSECONDTYPE> bool   Is__In__         (ANYTYPE value,   map<ANYSECONDTYPE, ANYTYPE> input_map)'
- source: '                    {'
- source: '                        if (Is__ValueIn__Map(value, input_map))'
- source: '                            return true;'
- source: '                    }'
- source: '    // Misc '
- source: '        // how to test if a class has a member function '
- source: '            // SFINAE test'
- source: '            // from http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-template-to-check-for-a-functions-existence'
- source: '            //            template <typename ANYTYPE>'
- source: '            //            class has_nameoffunction'
- source: '            //                {'
- source: '            //                    typedef char one;'
- source: '            //                    typedef long two;'
- source: '            //'
- source: '            //                    template <typename TEST_CLASS> static one test( decltype(&TEST_CLASS::nameoffunction) ) ;'
- source: '            //                    template <typename TEST_CLASS> static two test(...);    '
- source: '            //'
- source: '            //                public:'
- source: '            //                    enum { value = sizeof(test<ANYTYPE>(0)) == sizeof(char) };'
- source: '            //                };'
- source: '            //            has_nameoffunction<class_that_you_want_to_test>::value // will return true if the class has the member function'
- source: '        // how to get class names '
- source: '            // derived this from '
- source: '            // http://stackoverflow.com/questions/3649278/how-can-i-get-the-class-name-from-a-c-object'
- source: '            // FIXME, I think this can be replaced with typeid() from #include <typeinfo> https://stackoverflow.com/questions/11310898/how-do-i-get-the-type-of-a-variable#11310937'
- source: '            #include <cxxabi.h>'
- source: '            template <class ANYTYPE>'
- source: '            string Type(ANYTYPE input)'
- source: '                {'
- source: '                    stringstream output;'
- source: '                    int status;'
- source: '                    char * demangled = abi::__cxa_demangle(typeid(input).name(),0,0,&status);'
- source: '                    output << demangled ;'
- source: '                    free(demangled);'
- source: '                    return output.str();'
- source: '                }'
- source: ////////////////////////
- source: //
- source: //  Custom Types
- source: //
- source: ////////////////////////
- source: '    // pre-declare Item'
- source: '    class Item;     '
- source: '    // List'
- source: '    template <typename ITEM> class List'
- source: '        {'
- source: '            // data'
- source: '                vector<ITEM>    vector_ ;'
- source: '                vector<ITEM>    values  ;'
- source: '                vector<string>  names   ; '
- source: '        public:'
- source: '            // member functions '
- source: '                // NumberOfItems    '
- source: '                    int NumberOfItems() const '
- source: '                        { '
- source: '                            return vector_.size()+names.size(); '
- source: '                        }'
- source: '                // AddToBottom      '
- source: '                    template <class ANYTYPE> void AddToBottom(const ANYTYPE& input )'
- source: '                        {'
- source: '                            vector_ .push_back( ITEM(input) );'
- source: '                        }'
- source: '                // *AddToTop        '
- source: '                        // needs to change the index of everything in_ map'
- source: '                        // needs to '
- source: '                // *ExtractTopItem'
- source: '                // *ExtractBottomItem'
- source: '                // Remove__ThItem   '
- source: '                    void Remove__ThItem  (const long int& item_position  )'
- source: '                        {'
- source: '                            if ( item_position > vector_.Size() or item_position < 1 ) { '
- source: '                                Error( "Somewhere there''s a command trying to use Remove__ThItem() with an out-of-bounds value\n" );'
- source: '                            }  '
- source: '                            Remove__ThElementFrom__Vector((item_position -1), vector_);'
- source: '                        } '
- source: '                // Remove__         '
- source: '                    void Remove__  (const string& name  )'
- source: '                        {'
- source: '                            { int Max_Value =  names .size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { int EachItem = LoopNumber - 1;'
- source: '                                if ( name == names.at(EachItem) )'
- source: '                                    {'
- source: '                                        Remove__ThElementFrom__Vector(EachItem, names );'
- source: '                                        Remove__ThElementFrom__Vector(EachItem, values);'
- source: '                                        // should be able to end because there should be no duplicate name entrys '
- source: '                                        return;'
- source: '                                    }'
- source: '                            } }'
- source: '                        } '
- source: '                // From__To__       '
- source: '                    List<ITEM>     From__To__      (const int& starting_spot, const int& ending_spot ) '
- source: '                        {'
- source: '                            List<ITEM> output_list; '
- source: '                            { int Max_Value =   (ending_spot - starting_spot ) + 1     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { '
- source: '                                    output_list.AddToBottom(vector_.at(LoopNumber-1));'
- source: '                             } }'
- source: '                            return output_list; '
- source: '                        }'
- source: '                // *RemoveFrom__To__'
- source: '                // Data             '
- source: '                    vector<ITEM> Data () const '
- source: '                        { '
- source: '                            return vector_ + values;   '
- source: '                        }'
- source: '                // Vector           '
- source: '                    vector<ITEM> Vector () const '
- source: '                        { '
- source: '                            return vector_;   '
- source: '                        }'
- source: '                // Names            '
- source: '                    vector<string> Names() const'
- source: '                        {'
- source: '                                return names;'
- source: '                        }'
- source: '                // NamedValues      '
- source: '                    vector<ITEM> NamedValues () const '
- source: '                        { '
- source: '                            return values;   '
- source: '                        }'
- source: '                // Is__AName        '
- source: '                        template<class ANYTYPE> bool Is__AName(ANYTYPE input_)'
- source: '                            {'
- source: '                                // if its not a string then it can''t be a name '
- source: '                                ITEM input_as_item = ITEM(input_);'
- source: '                                if ( input_as_item.Type() != "string" ) { '
- source: '                                    return false;'
- source: '                                }  '
- source: '                                return Is__In__Vector(input_as_item.Data(), names);'
- source: '                            }'
- source: '                // Is__ANamedValue  '
- source: '                            template <class ANYTYPE> bool Is__ANamedValue(ANYTYPE input)'
- source: '                                {'
- source: '                                    return Is__In__Vector(ITEM(input),values);'
- source: '                                }'
- source: '                // Is__AVectorValue '
- source: '                            template <class ANYTYPE> bool Is__AVectorValue(ANYTYPE input)'
- source: '                                {'
- source: '                                    return Is__In__Vector(ITEM(input),vector_);'
- source: '                                }'
- source: '                // Is__AValue       '
- source: '                            template <class ANYTYPE> bool Is__AValue(ANYTYPE input)'
- source: '                                {'
- source: '                                    if ( Is__In__Vector(ITEM(input),values) )'
- source: '                                        return true;'
- source: '                                    if ( Is__In__Vector(ITEM(input),vector_) )'
- source: '                                        return true;'
- source: '                                    return false;'
- source: '                                }'
- source: '                // Has              '
- source: '                        template <class ANYTYPE> bool Has(ANYTYPE input)'
- source: '                                {'
- source: '                                    return Is__AName(ITEM(input)) || Is__ANamedValue(ITEM(input)) || Is__AValue(ITEM(input));'
- source: '                                }'
- source: '                // SizeOfLargestName'
- source: '                    int SizeOfLargestName() const'
- source: '                        {'
- source: '                            int largest_size =0;'
- source: '                            for( auto const& each : names )'
- source: '                                {'
- source: '                                    if (each.size() > largest_size)'
- source: '                                        {'
- source: '                                            largest_size = each.size();'
- source: '                                        }'
- source: '                                }  '
- source: '                            return largest_size;'
- source: '                        }'
- source: '                // Sample           '
- source: '                    string  Sample() const'
- source: '                        { '
- source: '                            // if theres nothing in_ the list, return nothing '
- source: '                            if (vector_.size() == 0)'
- source: '                                return "*NOTHING*";'
- source: '                            short int first_few = (vector_.size() > 3) ? 3 : vector_.size();'
- source: '                            string output_string = "";'
- source: '                            { int Max_Value =  first_few     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) {'
- source: '                                output_string = output_string + vector_.at(LoopNumber-1).Data() + ''\n'' ;'
- source: '                             } }'
- source: '                            return output_string;'
- source: '                        }'
- source: '                // At               '
- source: '                    ITEM& At (int position )'
- source: '                        {'
- source: '                            bool is_in_bounds = abs(position) <= vector_.size() && position != 0;'
- source: '                            bool is_negative  = position      < 0;'
- source: '                            if ( is_in_bounds ) '
- source: '                                { '
- source: '                                    if ( is_negative ) '
- source: '                                        { '
- source: '                                            // if -1 then return the last element '
- source: '                                            // if -2 then return 2nd-to-last element '
- source: '                                            // etc '
- source: '                                            return vector_.at(vector_.size() + position);'
- source: '                                        } '
- source: '                                    else '
- source: '                                        { '
- source: '                                            return vector_.at(position-1);'
- source: '                                        }  '
- source: '                                } '
- source: '                            else '
- source: '                                { '
- source: '                                    if ( is_negative ) '
- source: '                                        { '
- source: '                                            Error(  "Somewhere the code is asking for item "+to_string(position)+" in_ a list\b"'
- source: '                                                +"But that item doesn''t exist :/\n" '
- source: '                                                +"Here is a sample of the list:\n"'
- source: '                                                +this->Sample() );'
- source: '                                            // if the position doesnt exist, then create it (and all of the inbetween values)'
- source: '                                        } '
- source: '                                    else '
- source: '                                        {'
- source: '                                            int missing_items = position - vector_.size();'
- source: '                                            { int Max_Value =  missing_items     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { '
- source: '                                                vector_.push_back(ITEM());'
- source: '                                             } }'
- source: '                                            return vector_.at(position-1);'
- source: '                                        } '
- source: '                                }  // end if is_in_bounds'
- source: '                        } // end at'
- source: '                // Input            '
- source: '                    istream& Input  (istream& in_)'
- source: '                        {'
- source: '                            // check name of type '
- source: '                            if ( EverythingUpTo(''\n'',in_) != "List\n")'
- source: '                                return StreamFailed(in_);'
- source: '                                    // unindent members'
- source: '                                    string content = Input_Unindent(in_);'
- source: '                                    // check fail'
- source: '                                    if (content == "")'
- source: '                                        return StreamFailed(in_);'
- source: '                                    // check end '
- source: '                                    if (content[content.size()-1] != ''\n'')'
- source: '                                        return StreamFailed(in_);'
- source: '                                    // setup vars'
- source: '                                    char should_always_be_a_newline;'
- source: '                                    stringstream transfer_method;'
- source: '                                    // get rid of the class''s newline'
- source: '                                    transfer_method << content.substr(0,content.size()-1);'
- source: '                            // create empty versions of all data members '
- source: '                            input( transfer_method , vector_ ); transfer_method.get(should_always_be_a_newline);'
- source: '                            input( transfer_method , values  ); transfer_method.get(should_always_be_a_newline);'
- source: '                            input( transfer_method , names   ); transfer_method.get(should_always_be_a_newline);'
- source: '                                    // if stream fails, then return fail '
- source: '                                    if (DidStreamFail(transfer_method))'
- source: '                                        return StreamFailed(in_);'
- source: '                                    // if everything worked return the stream! '
- source: '                                    return in_;'
- source: '                        }  '
- source: '            // internal overloads'
- source: '                Item& operator[] (long int position) '
- source: '                    {'
- source: '                        return this->At(position);'
- source: '                    }'
- source: '                Item& operator[] (string   name) '
- source: '                    {'
- source: '                        // if name is in_ names, return the value'
- source: '                        long int index_ = IndexOf__In__Vector(name, names);'
- source: '                        if ( index_ != -1 )'
- source: '                            {'
- source: '                                return values.at(index_);'
- source: '                            }'
- source: '                        else '
- source: '                            {'
- source: '                                // add the name '
- source: '                                names .push_back(  name  );'
- source: '                                values.push_back( ITEM() );'
- source: '                                // return the Item '
- source: '                                return values.at(values.size()-1);'
- source: '                            }'
- source: '                    }'
- source: '                template <class ANYTYPE> List<ITEM>& operator=  (vector<ANYTYPE> const &assignment_data) '
- source: '                    { '
- source: '                        vector_ = {};'
- source: '                        { int Max_Value =  assignment_data .size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { int EachItem = LoopNumber - 1; '
- source: '                            vector_.push_back(     Item(  assignment_data.at(EachItem)  )     );'
- source: '                        } } '
- source: '                        return *this;'
- source: '                    }'
- source: '                List<ITEM>& operator=  (vector<Item> const &assignment_data) '
- source: '                    { '
- source: '                        vector_ = assignment_data; '
- source: '                        return *this;'
- source: '                    }'
- source: '        };'
- source: '            // external overloads '
- source: '                // IO          '
- source: '                    template <class ITEM> ostream& output (ostream& out, const List<ITEM>& input_)'
- source: '                        {'
- source: '                            // name of class '
- source: '                            out << "List" << ''\n'';'
- source: '                                    stringstream data_members;'
- source: '                            // for each datamember'
- source: '                            output( data_members , input_.Vector     ()); data_members << ''\n'';'
- source: '                            output( data_members , input_.Names      ()); data_members << ''\n'';'
- source: '                            output( data_members , input_.NamedValues()); data_members << ''\n'';'
- source: '                                    // format and return stream'
- source: '                                    out << Indent( data_members.str() ) << ''\n'';'
- source: '                                    return out;'
- source: '                        }'
- source: '                    template <class ITEM> istream& input  (istream& in_,        List<ITEM>& input_)'
- source: '                        {'
- source: '                            return input_.Input(in_);'
- source: '                        }  '
- source: '                // VisualFormat'
- source: '                        template <typename ITEM> string VisualFormat( const List<ITEM>& input_)'
- source: '                            {'
- source: '                                // output both'
- source: '                                if ( input_.NamedValues().size() >= 1 and input_.Vector().size() >= 1 ) '
- source: '                                    {'
- source: '                                        stringstream named_values_stream;'
- source: '                                        { int Max_Value =  input_.Names() .size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { int EachItem = LoopNumber - 1; '
- source: '                                            named_values_stream << setw(15) << input_.Names().at(EachItem) << " : " << input_.NamedValues().at(EachItem) << ''\n'';'
- source: '                                        } } '
- source: '                                        return '
- source: '                                            "Vector\n" + '
- source: '                                                VisualFormat(input_.Vector())+ '
- source: '                                            "Named Values\n"+ '
- source: '                                                Indent(named_values_stream.str());'
- source: '                                    }'
- source: '                                // just output vector '
- source: '                                else if ( input_.Vector().size() >= 1 ) '
- source: '                                    {'
- source: '                                        return "List\n" + VisualFormat(input_.Vector());'
- source: '                                    }'
- source: '                                // just output named values '
- source: '                                else if ( input_.Names().size() >= 1 )'
- source: '                                    {'
- source: '                                        stringstream output_stream;'
- source: '                                        { int Max_Value =  input_.Names() .size()     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { int EachItem = LoopNumber - 1; '
- source: '                                            output_stream << setw(15) << input_.Names().at(EachItem) << " : " << input_.Vector().at(EachItem) << ''\n'';'
- source: '                                        } } '
- source: '                                        return "List\n" + Indent(output_stream.str());'
- source: '                                    }'
- source: '                                else '
- source: '                                    // output *NOTHING*  '
- source: '                                    return "*NOTHING*\n";'
- source: '                            }     '
- source: '                // << >>       '
- source: '                    template <typename ITEM> ostream& operator<<(ostream& out, const List<ITEM>& input_)'
- source: '                        {'
- source: '                            return out << VisualFormat(input_);'
- source: '                        } '
- source: '                    template <typename ITEM> istream& operator>>(istream& in_,        List<ITEM>& input_)'
- source: '                        {'
- source: '                            return input(in_, input_);'
- source: '                        }'
- source: '    // make it so that List is List<Item>'
- source: '    #define List List<Item>'
- source: '    // name some other names for items '
- source: '    #define var Item'
- source: '    // '
- source: '    //  Item'
- source: '    // '
- source: '    class  Item '
- source: '        {'
- source: '            // data'
- source: '                string data; // later turn both of these into some kind of binary'
- source: '                string type; '
- source: '        public:'
- source: '            // constructors   '
- source: '                    explicit Item (                       ) { data =  "Nothing"      ; type = "Nothing";}'
- source: '                    explicit Item ( char   input_string[] ) { data =  input_string   ; type = "string" ;}'
- source: '                    explicit Item ( string input_string   ) { data =  input_string   ; type = "string" ;}'
- source: '                    explicit Item ( double input_         ) '
- source: '                        { '
- source: '                            stringstream input_method;'
- source: '                            // precision should max out before 20'
- source: '                            input_method << setprecision(20) << input_ ;'
- source: '                            data = input_method.str(); '
- source: '                            type = "number" ;'
- source: '                        }'
- source: '                    template<class ANYTYPE> explicit Item ( ANYTYPE input )'
- source: '                            { '
- source: '                                stringstream data_stream;'
- source: '                                output(data_stream, input);'
- source: '                                // get the name'
- source: '                                type = EverythingUpTo(''\n'', data_stream);'
- source: '                                type = type.substr(0,type.size()-1);'
- source: '                                // get the content'
- source: '                                string content = Input_Unindent(data_stream);'
- source: '                                // remove the closing newline'
- source: '                                content = content.substr(0,content.size()-1);'
- source: '                                data = content;'
- source: '                                if (type == "double" || type == "integer")'
- source: '                                    type = "number"; '
- source: '                            }'
- source: '            // methods        '
- source: '                    string Type()        const { return type ; }'
- source: '                    string Data()        const { return data ; }'
- source: '                    string Remove0s   () const      '
- source: '                        {'
- source: '                            if ( stoi(data) == stold(data) ) {'
- source: '                                return to_string(stoi(data));'
- source: '                            } else {'
- source: '                                //FIXME, change this to remove trailing 0''s '
- source: '                                return data;'
- source: '                            }  '
- source: '                        } '
- source: '                    istream& Input  (istream& in_)'
- source: '                        {'
- source: '                            // check name of type '
- source: '                            if ( EverythingUpTo(''\n'',in_) != "Item\n")'
- source: '                                return StreamFailed(in_);'
- source: '                                    // unindent members'
- source: '                                    string content = Input_Unindent(in_);'
- source: '                                    // check fail'
- source: '                                    if (content == "")'
- source: '                                        return StreamFailed(in_);'
- source: '                                    // check end '
- source: '                                    if (content[content.size()-1] != ''\n'')'
- source: '                                        return StreamFailed(in_);'
- source: '                                    // setup vars'
- source: '                                    char should_always_be_a_newline;'
- source: '                                    stringstream transfer_method;'
- source: '                                    // get rid of the class''s newline'
- source: '                                    transfer_method << content.substr(0,content.size()-1);'
- source: '                            // create empty versions of all data members '
- source: '                            input( transfer_method, data ); transfer_method.get(should_always_be_a_newline);'
- source: '                            input( transfer_method, type ); transfer_method.get(should_always_be_a_newline);'
- source: '                                    // if stream fails, then return fail '
- source: '                                    if (DidStreamFail(transfer_method))'
- source: '                                        return StreamFailed(in_);'
- source: '                            // check the data, make sure its valid '
- source: '                            // FIXME, do this later'
- source: '                            //if ( !IsDataValid(datamember)) '
- source: '                            //    return StreamFailed(in_);'
- source: '                                    // if everything worked return the stream! '
- source: '                                    return in_;'
- source: '                        }  '
- source: '            // operators      '
- source: '                // =      '
- source: '                    Item& operator=( const Item&  input_item    ) { data = input_item.Data()         ; type = input_item.Type(); return *this; }'
- source: '                    Item& operator=( const char   input_string[]) { data = input_string              ; type = "string"         ; return *this; }'
- source: '                    Item& operator=( const string input_string  ) { data = input_string              ; type = "string"         ; return *this; }'
- source: '                    Item& operator=( const int    the_inputeger ) { data = to_string(the_inputeger)  ; type = "number"         ; return *this; }'
- source: '                    Item& operator=( const float  input_        ) '
- source: '                        { '
- source: '                            stringstream input_method;'
- source: '                            // precision should max out before 20'
- source: '                            input_method << setprecision(20) << input_ ;'
- source: '                            data = input_method.str(); '
- source: '                            type = "number"; '
- source: '                            return *this; '
- source: '                        }'
- source: '                    Item& operator=( const double input_        ) '
- source: '                        { '
- source: '                            stringstream input_method;'
- source: '                            // precision should max out before 20'
- source: '                            input_method << setprecision(20) << input_ ;'
- source: '                            data = input_method.str();'
- source: '                            type = "number"; '
- source: '                            return *this; '
- source: '                        }'
- source: '                    template<class ANYTYPE> Item& operator=( ANYTYPE input_ ) '
- source: '                        { '
- source: '                            stringstream data_stream;'
- source: '                            data_stream << input_;'
- source: '                            data = data_stream.str();'
- source: '                            type = "Unknown";'
- source: '                            return *this; '
- source: '                        }'
- source: '                // implicit conversion '
- source: '                    operator string() const '
- source: '                        {'
- source: '                                return data;'
- source: '                        }'
- source: '                    operator double() const '
- source: '                        {'
- source: '                            if ( type == "number" ) {'
- source: '                                return stold(data);'
- source: '                            } else {'
- source: '                                Error("Somewhere there is an item thats not a number,\nand something is trying to make it a double\nthe item is "+data);'
- source: '                            }  '
- source: '                        } '
- source: '        };'
- source: '        // IO'
- source: '            ostream& output (ostream& out, const Item& input_)'
- source: '                {'
- source: '                    // name of class '
- source: '                    out << "Item" << ''\n'';'
- source: '                            stringstream data_members;'
- source: '                    // for each datamember'
- source: '                    output( data_members , input_.Data()); data_members << ''\n'';'
- source: '                    output( data_members , input_.Type()); data_members << ''\n'';'
- source: '                            // format and return stream'
- source: '                            out << Indent( data_members.str() );'
- source: '                            return out;'
- source: '                }'
- source: '            istream& input  (istream& in_,        Item& input_)'
- source: '                {'
- source: '                    return input_.Input(in_);'
- source: '                }  '
- source: '            string   AsData (const Item& input_)'
- source: '                {'
- source: '                    stringstream out;'
- source: '                    // name of class '
- source: '                    out << input_.Type() << ''\n'';'
- source: '                    stringstream data_members;'
- source: '                    // for each datamember'
- source: '                    data_members << input_.Data() << ''\n'';'
- source: '                    // format and return stream'
- source: '                    out << Indent( data_members.str() );'
- source: '                    return out.str();'
- source: '                }'
- source: '        // overloads'
- source: '                // >>   '
- source: '                    ostream& operator<<(ostream& out, const Item& input_)'
- source: '                        {'
- source: '                            // number'
- source: '                            if (input_.Type() == "number")'
- source: '                                return out << stold(input_.Data());'
- source: '                            // list '
- source: '                            if (input_.Type() == "List")'
- source: '                                {'
- source: '                                    // create a blank list '
- source: '                                    List blank_list;'
- source: '                                    // put the data into a stream'
- source: '                                    stringstream data_stream;'
- source: '                                    data_stream << AsData(input_);'
- source: '                                    char should_always_be_a_newline;'
- source: '                                    // populate the list '
- source: '                                    input(data_stream, blank_list);'
- source: '                                    // output list using it''s own stream operator'
- source: '                                    return out << blank_list;'
- source: '                                }'
- source: '                            return out << input_.Data();'
- source: '                        }'
- source: '                    istream& operator>>(istream& in_,        Item& input_)'
- source: '                        {'
- source: '                            return input(in_,input_);'
- source: '                        }'
- source: '                    // what to do about lists, bool''s, Grids'
- source: '                // +'
- source: '                    Item  operator+( const string&  base   , const int&   repetitions  )'
- source: '                        {'
- source: '                            string result;'
- source: '                            for (int i = 0; i < repetitions; i++)'
- source: '                                result += base;'
- source: '                            return Item(result);'
- source: '                        }'
- source: '                    Item  operator+( const char     the_input[] , const Item&   input_item  )'
- source: '                        {'
- source: '                            if ( input_item.Type() == "string" ) { '
- source: '                                return Item(input_item.Data() + the_input);'
- source: '                            } else { '
- source: '                                Error("Trying to add a non-string Item: "+input_item.Data()+" to a string: " + the_input);'
- source: '                            } '
- source: '                        }                 '
- source: '                    Item  operator+( const int&     the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if (input_item.Type() == "number")'
- source: '                                return  Item(Item(stod(input_item.Data()) + the_input));'
- source: '                            else'
- source: '                                Error("Trying to add an int: "+to_string(input_item)+ " to non-number Item "+ input_item.Data());'
- source: '                        }'
- source: '                    Item  operator+( const double&  the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if (input_item.Type() == "number")'
- source: '                                return  Item(Item(stod(input_item.Data()) + the_input));'
- source: '                            else'
- source: '                                Error("Trying to add a double: "+to_string(input_item)+ " to non-number Item "+ input_item.Data());'
- source: '                        }'
- source: '                    Item  operator+( const string&  the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                                if ( input_item.Type() == "number" ) {'
- source: '                                    return  Item(the_input + input_item.Remove0s());'
- source: '                                } else { '
- source: '                                    return Item(the_input + input_item.Data());'
- source: '                                }  '
- source: '                        } '
- source: '                    Item  operator+( const Item&    input_item  , const char    the_input[] )'
- source: '                        {'
- source: '                            if ( input_item.Type() == "string" ) { '
- source: '                                return Item(input_item.Data() + the_input);'
- source: '                            } else { '
- source: '                                Error("Trying to add a non-string Item: "+input_item.Data()+" to a string: " + the_input);'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator+( const Item&    input_item  , const int&    the_input   )'
- source: '                        { '
- source: '                            if (input_item.Type() == "number")'
- source: '                                return Item(stod(input_item.Data()) + the_input);'
- source: '                            else'
- source: '                                Error("Trying to add an int: "+to_string(input_item)+ " to a non-number Item "+ input_item.Data());'
- source: '                        }'
- source: '                    Item  operator+( const Item&    input_item  , const double& the_input   )'
- source: '                        { '
- source: '                            if (input_item.Type() == "number")'
- source: '                                return Item(stod(input_item.Data()) + the_input);'
- source: '                            else'
- source: '                                Error("Trying to add a double: "+to_string(input_item)+ " to a non-number Item "+ input_item.Data());'
- source: '                        }'
- source: '                    Item  operator+( const Item&    input_item  , const string& the_input   )'
- source: '                        { '
- source: '                                if ( input_item.Type() == "number" ) {'
- source: '                                    return Item(input_item.Remove0s() + the_input);'
- source: '                                } else { '
- source: '                                    return Item(input_item.Data() + the_input);'
- source: '                                }  '
- source: '                        } '
- source: '                    Item  operator+( const Item&    input_item1 , const Item&   input_item2 )'
- source: '                        {'
- source: '                            if ( input_item1.Type() == "number" && input_item2.Type() == "number" ) {'
- source: '                                return Item(stold(input_item1.Data()) + stold(input_item2.Data()));'
- source: '                            } else {'
- source: '                                return Item(input_item1.Data() + input_item2.Data());'
- source: '                            }  '
- source: '                        }'
- source: '                // -    '
- source: '                    Item  operator-( const int&     the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if (input_item.Type() == "number")'
- source: '                                return  Item( the_input - stod(input_item.Data()));'
- source: '                            else'
- source: '                                Error("Trying to subtract an int: "+to_string(input_item)+ " from a non-number Item "+ input_item.Data());'
- source: '                        }'
- source: '                    Item  operator-( const double&  the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if (input_item.Type() == "number")'
- source: '                                return  Item(the_input - stod(input_item.Data()));'
- source: '                            else'
- source: '                                Error("Trying to subtract a double: "+to_string(input_item)+ " from a non-number Item "+ input_item.Data());'
- source: '                        }'
- source: '                    Item  operator-( const Item&    input_item  , const int&    the_input   )'
- source: '                        { '
- source: '                            if (input_item.Type() == "number")'
- source: '                                return  Item(stod(input_item.Data()) - the_input);'
- source: '                            else'
- source: '                                Error("Trying to subtract a non-number Item: "+input_item.Data()+ " from an int: "+to_string(input_item));'
- source: '                        }'
- source: '                    Item  operator-( const Item&    input_item  , const double& the_input   )'
- source: '                        { '
- source: '                            if (input_item.Type() == "number")'
- source: '                                return  Item(the_input - stod(input_item.Data()));'
- source: '                            else'
- source: '                                Error("Trying to subtract a non-number Item: "+input_item.Data()+ " from a double "+to_string(input_item));'
- source: '                        }'
- source: '                    Item  operator-( const Item&    input_item1 , const Item&   input_item2 )'
- source: '                        {'
- source: '                            if ( input_item1.Type() == "number" && input_item2.Type() == "number" ) {'
- source: '                                return  Item( Item(stold(input_item1.Data()) - stold(input_item2.Data())));'
- source: '                            } else {'
- source: '                                Error(string("I think somewhere in_ the code there is one item subtracting another")'
- source: '                                    +"\nbut they are not both numbers"'
- source: '                                    +"\nthe items are "'
- source: '                                    +input_item1.Data()'
- source: '                                    +" and "'
- source: '                                    +input_item2.Data()'
- source: '                                    +"\n");'
- source: '                            }  '
- source: '                        }'
- source: '                // *'
- source: '                    Item  operator*( const string&  the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "string"  ) { '
- source: '                                Error("Somewhere there is a string Item: "+input_item.Data()+" being multipled by a string");'
- source: '                            } else if (  input_item.Type() == "number"  ) { '
- source: '                                int number_ = stoi(input_item.Data());'
- source: '                                if ( number_ == 0 ) { '
- source: '                                    return  Item(string(""));'
- source: '                                } else if ( number_ > 0 ) { '
- source: '                                    string output_string; '
- source: '                                    { int Max_Value =  number_     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { '
- source: '                                        output_string = output_string + the_input;'
- source: '                                     } } '
- source: '                                    return Item(output_string);'
- source: '                                } else { '
- source: '                                    Error("Somewhere there is a string be multipled by a negative Item");'
- source: '                                }  '
- source: '                            } '
- source: '                        }  '
- source: '                    Item  operator*( const int&     the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "string"  ) { '
- source: '                                int number_ = static_cast<int>(  the_input  );'
- source: '                                if ( number_ == 0 ) { '
- source: '                                    return  Item(string(""));'
- source: '                                } else if ( number_ > 0 ) { '
- source: '                                    string output_string; '
- source: '                                    { int Max_Value =  number_     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { '
- source: '                                        output_string = output_string + input_item.Data();'
- source: '                                     } } '
- source: '                                    return Item(output_string);'
- source: '                                } else { '
- source: '                                    Error("Somewhere there is a string be multipled by a negative Item");'
- source: '                                }  '
- source: '                            } else if (  input_item.Type() == "number"  ) { '
- source: '                                return Item(the_input + stold(input_item.Data()));'
- source: '                            } '
- source: '                        }  '
- source: '                    Item  operator*( const double&  the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "string"  ) { '
- source: '                                int number_ = static_cast<int>(  the_input  );'
- source: '                                if ( number_ == 0 ) { '
- source: '                                    return  Item(string(""));'
- source: '                                } else if ( number_ > 0 ) { '
- source: '                                    string output_string; '
- source: '                                    { int Max_Value =  number_     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { '
- source: '                                        output_string = output_string + input_item.Data();'
- source: '                                     } } '
- source: '                                    return Item(output_string);'
- source: '                                } else { '
- source: '                                    Error("Somewhere there is a string be multipled by a negative Item");'
- source: '                                }  '
- source: '                            } else if (  input_item.Type() == "number"  ) { '
- source: '                                return Item(the_input + stold(input_item.Data()));'
- source: '                            } '
- source: '                        }  '
- source: '                    Item  operator*( const char&    the_input   , const Item&   input_item  )'
- source: '                        {'
- source: '                            return  Item(AsString(the_input) * input_item);'
- source: '                        }'
- source: '                    Item  operator*( const Item&    input_item  , const double& the_input   )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "string"  ) { '
- source: '                                int number_ = static_cast<int>(  the_input  );'
- source: '                                if ( number_ == 0 ) { '
- source: '                                    return  Item(string(""));'
- source: '                                } else if ( number_ > 0 ) { '
- source: '                                    string output_string; '
- source: '                                    { int Max_Value =  number_     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { '
- source: '                                        output_string = output_string + input_item.Data();'
- source: '                                     } } '
- source: '                                    return Item(output_string);'
- source: '                                } else { '
- source: '                                    Error("Somewhere there is a string be multipled by a negative Item");'
- source: '                                }  '
- source: '                            } else if (  input_item.Type() == "number"  ) { '
- source: '                                return Item(the_input + stold(input_item.Data()));'
- source: '                            } '
- source: '                        }                  '
- source: '                    Item  operator*( const Item&    input_item  , const int&    the_input   )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "string"  ) { '
- source: '                                int number_ = static_cast<int>(  the_input  );'
- source: '                                if ( number_ == 0 ) { '
- source: '                                    return  Item(string(""));'
- source: '                                } else if ( number_ > 0 ) { '
- source: '                                    string output_string; '
- source: '                                    { int Max_Value =  number_     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { '
- source: '                                        output_string = output_string + input_item.Data();'
- source: '                                     } } '
- source: '                                    return Item(output_string);'
- source: '                                } else { '
- source: '                                    Error("Somewhere there is a string be multipled by a negative Item");'
- source: '                                }  '
- source: '                            } else if (  input_item.Type() == "number"  ) { '
- source: '                                return Item(the_input + stold(input_item.Data()));'
- source: '                            } '
- source: '                        }  '
- source: '                    Item  operator*( const Item&    input_item  , const string& the_input   )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "string"  ) { '
- source: '                                Error("Somewhere there is a string Item being multipled by a string");'
- source: '                            } else if (  input_item.Type() == "number"  ) { '
- source: '                                int number_ = stoi(input_item.Data());'
- source: '                                if ( number_ == 0 ) { '
- source: '                                    return  Item(string(""));'
- source: '                                } else if ( number_ > 0 ) { '
- source: '                                    string output_string; '
- source: '                                    { int Max_Value =  number_     ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) { '
- source: '                                        output_string = output_string + the_input;'
- source: '                                     } } '
- source: '                                    return Item(output_string);'
- source: '                                } else { '
- source: '                                    Error("Somewhere there is a string be multipled by a negative Item");'
- source: '                                }  '
- source: '                            } '
- source: '                        }  '
- source: '                    Item  operator*( const Item&    input_item  , const char&   the_input   )'
- source: '                        {'
- source: '                            return  Item(input_item * AsString(the_input) );'
- source: '                        }'
- source: '                    Item  operator*( const Item&    input_item1 , const Item&   input_item2 )'
- source: '                        {'
- source: '                            if ( ( input_item1.Type() == "string" && input_item2.Type() == "number" ) ) { '
- source: '                                return  Item(input_item1 * stod(input_item2.Data()));'
- source: '                            } else if (( input_item1.Type() == "number" && input_item2.Type() == "string" )'
- source: '                                ) {'
- source: '                                    return Item(stod(input_item1.Data()) * input_item2);'
- source: '                            } else if (( input_item1.Type() == "number" && input_item2.Type() == "number" )'
- source: '                                ) {'
- source: '                                    return Item(stod(input_item1.Data()) * stod(input_item2.Data()));'
- source: '                            } else {'
- source: '                                Error(string("I think somewhere in_ the code there is one item multipling another")'
- source: '                                    +"\nbut neither of them are numbers"'
- source: '                                    +"\nthe items are "'
- source: '                                    +input_item1.Data() + " type: " + input_item1.Type()'
- source: '                                    +" and "'
- source: '                                    +input_item2.Data() + " type: " + input_item2.Type()'
- source: '                                    +"\n");'
- source: '                            }  '
- source: '                        }'
- source: '                // /    '
- source: '                    Item  operator/( const Item&    input_item  , const int&    the_input   )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "number"  ) { '
- source: '                                if ( the_input ==0 ) { '
- source: '                                    Error("Division by 0 somewhere");'
- source: '                                } '
- source: '                                return  Item((long double)(stold( input_item.Data() ) / the_input));'
- source: '                            } else { '
- source: '                                Error("Trying to divide something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator/( const Item&    input_item  , const float&  the_input   )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "number"  ) { '
- source: '                                return  Item(stold( input_item.Data() ) / the_input);'
- source: '                            } else { '
- source: '                                Error("Trying to divide something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator/( const Item&    input_item  , const double& the_input   )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "number"  ) { '
- source: '                                return  Item(stold( input_item.Data() ) / the_input);'
- source: '                            } else { '
- source: '                                Error("Trying to divide something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator/( const int&     the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "int" ) { '
- source: '                                if ( stoi( input_item.Data() ) == 0 ) { '
- source: '                                    Error("Division by 0 somewhere");'
- source: '                                } else {'
- source: '                                    return  Item( the_input / stold( input_item.Data() ));'
- source: '                                }  '
- source: '                            } else if ( input_item.Type() == "double" ) {'
- source: '                                if (     stod( input_item.Data() ) <  0.00000000001 '
- source: '                                    && stod( input_item.Data() ) > -0.00000000001 '
- source: '                                ) { '
- source: '                                    Error("Division by 0 somewhere");'
- source: '                                } else {'
- source: '                                    return Item(the_input / stold( input_item.Data() ));'
- source: '                                }  '
- source: '                            } else if ( input_item.Type() == "float"  ) { '
- source: '                                if (     stof( input_item.Data() ) <  0.00001 '
- source: '                                    && stof( input_item.Data() ) > -0.00001 '
- source: '                                ) { '
- source: '                                    Error("Division by 0 somewhere");'
- source: '                                } else {'
- source: '                                    return Item(the_input / stold( input_item.Data() ));'
- source: '                                }  '
- source: '                            } else { '
- source: '                                Error("Trying to divide something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator/( const float&   the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "int" ) { '
- source: '                                if ( stoi( input_item.Data() ) == 0 ) { '
- source: '                                    Error("Division by 0 somewhere");'
- source: '                                } else {'
- source: '                                    return  Item( the_input / stold( input_item.Data() ));'
- source: '                                }  '
- source: '                            } else if ( input_item.Type() == "double" ) {'
- source: '                                if (     stod( input_item.Data() ) <  0.00000000001 '
- source: '                                    && stod( input_item.Data() ) > -0.00000000001 '
- source: '                                ) { '
- source: '                                    Error("Division by 0 somewhere");'
- source: '                                } else {'
- source: '                                    return Item(the_input / stold( input_item.Data() ));'
- source: '                                }  '
- source: '                            } else if ( input_item.Type() == "float"  ) { '
- source: '                                if (     stof( input_item.Data() ) <  0.00001 '
- source: '                                    && stof( input_item.Data() ) > -0.00001 '
- source: '                                ) { '
- source: '                                    Error("Division by 0 somewhere");'
- source: '                                } else {'
- source: '                                    return Item(the_input / stold( input_item.Data() ));'
- source: '                                }  '
- source: '                            } else { '
- source: '                                Error("Trying to divide something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator/( const double&  the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "int" ) { '
- source: '                                if ( stoi( input_item.Data() ) == 0 ) { '
- source: '                                    Error("Division by 0 somewhere");'
- source: '                                } else {'
- source: '                                    return  Item( the_input / stold( input_item.Data() ));'
- source: '                                }  '
- source: '                            } else if ( input_item.Type() == "double" ) {'
- source: '                                if (     stod( input_item.Data() ) <  0.00000000001 '
- source: '                                    && stod( input_item.Data() ) > -0.00000000001 '
- source: '                                ) { '
- source: '                                    Error("Division by 0 somewhere");'
- source: '                                } else {'
- source: '                                    return Item(the_input / stold( input_item.Data() ));'
- source: '                                }  '
- source: '                            } else if ( input_item.Type() == "float"  ) { '
- source: '                                if (     stof( input_item.Data() ) <  0.00001 '
- source: '                                    && stof( input_item.Data() ) > -0.00001 '
- source: '                                ) { '
- source: '                                    Error("Division by 0 somewhere");'
- source: '                                } else {'
- source: '                                    return Item(the_input / stold( input_item.Data() ));'
- source: '                                }  '
- source: '                            } else { '
- source: '                                Error("Trying to divide something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator/( const Item&    input_item1 , const Item&   input_item2 )'
- source: '                        {'
- source: '                            if ( input_item1.Type() == "number" && input_item2.Type() == "number" ) {'
- source: '                                return  Item(stold(input_item1.Data()) / stold(input_item2.Data()));'
- source: '                            } else {'
- source: '                                Error(string("I think somewhere in_ the code there is one item dividing another")'
- source: '                                    +"\nbut they are not both numbers"'
- source: '                                    +"\nthe items are "'
- source: '                                    +input_item1.Data()'
- source: '                                    +" and "'
- source: '                                    +input_item2.Data()'
- source: '                                    +"\n");'
- source: '                            }  '
- source: '                        }'
- source: '                // ^    '
- source: '                    Item  operator^( const Item&    input_item  , const int&    the_input   )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "number"  ) { '
- source: '                                return  Item(pow(  stold( input_item.Data() ) , the_input));'
- source: '                            } else { '
- source: '                                Error("Trying to use an exponent with something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator^( const Item&    input_item  , const float&  the_input   )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "number"  ) { '
- source: '                                return  Item(pow(  stold( input_item.Data() ) , the_input));'
- source: '                            } else { '
- source: '                                Error("Trying to use an exponent with something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator^( const Item&    input_item  , const double& the_input   )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "number"  ) { '
- source: '                                return  Item(pow(  stold( input_item.Data() ) , the_input));'
- source: '                            } else { '
- source: '                                Error("Trying to use an exponent with something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator^( const int&     the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "number"  ) { '
- source: '                                return  Item(pow( the_input, stold( input_item.Data() )));'
- source: '                            } else { '
- source: '                                Error("Trying to use an exponent with something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator^( const float&   the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "number"  ) { '
- source: '                                return  Item(pow( the_input, stold( input_item.Data() )));'
- source: '                            } else { '
- source: '                                Error("Trying to use an exponent with something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator^( const double&  the_input   , const Item&   input_item  )'
- source: '                        { '
- source: '                            if ( input_item.Type() == "number"  ) { '
- source: '                                return  Item(pow( the_input, stold( input_item.Data() )));'
- source: '                            } else { '
- source: '                                Error("Trying to use an exponent with something from an item thats not a number");'
- source: '                            } '
- source: '                        }'
- source: '                    Item  operator^( const Item&    input_item1 , const Item&   input_item2 )'
- source: '                        {'
- source: '                            if ( input_item1.Type() == "number" && input_item2.Type() == "number" ) {'
- source: '                                return  Item(stod(input_item1.Data()) ^ input_item2);'
- source: '                            } else {'
- source: '                                Error(string("I think somewhere in_ the code there is one item to the power of another")'
- source: '                                    +"\nbut they are not both numbers"'
- source: '                                    +"\nthe items are "'
- source: '                                    +input_item1.Data()'
- source: '                                    +" and "'
- source: '                                    +input_item2.Data()'
- source: '                                    +"\n");'
- source: '                            }  '
- source: '                        }'
- source: '                //  Function overloads'
- source: '                    string to_string(const Item& input_item)'
- source: '                        { '
- source: '                            return input_item.Data();'
- source: '                        } '
- source: '    // List'
- source: '            // helpers '
- source: '                template <class ANYTYPE> bool   Is__In__ (ANYTYPE value,   List input_)'
- source: '                        {'
- source: '                            Item holder = value;'
- source: '                            return input_.Has(holder);'
- source: '                        }'
- source: '    /**/'
- source: //
- source: '// puts, print, and log '
- source: //
- source: '    // I made this code based on code from the site below'
- source: '    // I''ve had it for a long time and you can find it on my github'
- source: '    // I like to think I made it more useful, but all originalality '
- source: '    // goes to the original author'
- source: '    // http://wiki.c2.com/?OverloadingCommaOperator'
- source: '    // puts is the standard way to output things'
- source: '    #define puts        __PutsOutputFixerStream,'
- source: '    #define put_lines   __PutLinesOutputFixerStream.reset();__PutLinesOutputFixerStream,'
- source: '    // and print is puts without a newline'
- source: '    #define Print       cout,'
- source: '    // log is an incredibly useful Debugging tool'
- source: '    string __OUTPUT_INDENT = "";'
- source: '    bool __INCREASE_INDENT = false;'
- source: '    #define log                                                                                                                        __LogOutputFixerStream.reset();__LogOutputFixerStream,'
- source: '    #define log_start          __INCREASE_INDENT = true;                                                                                   __LogOutputFixerStream.reset();__LogOutputFixerStream,'
- source: '    #define log_end        if (__OUTPUT_INDENT.size() >= 4) { __OUTPUT_INDENT = __OUTPUT_INDENT.substr(0,__OUTPUT_INDENT.size()-4); } ;__LogOutputFixerStream.reset();__LogOutputFixerStream,'
- source: '    class __PutLinesOutputFixerStreamClass : public stringstream'
- source: '        {'
- source: '            protected:'
- source: '                // data '
- source: '                    int length_of_last_line = 0;'
- source: '                    bool dont_go_up_a_line = true;'
- source: '                    string what_was_just_output = "";'
- source: '                    string content = "";'
- source: '                // class helper functions'
- source: '                    void go_up_a_line()'
- source: '                        {'
- source: '                            cout << "\033[1A";'
- source: '                        }'
- source: '                    void go_to_the_right(int number_of_spaces)'
- source: '                        {'
- source: '                            cout << "\033["+to_string(number_of_spaces)+"C";'
- source: '                        }'
- source: '                    void save_cursor_position()'
- source: '                        {'
- source: '                            cout << "\033[s";'
- source: '                        }'
- source: '                    void restore_cursor_position()'
- source: '                        {'
- source: '                            cout << "\033[u";'
- source: '                        }'
- source: '                    int length_of_previous_line()'
- source: '                        {'
- source: '                            int charaters_till_newline = 0;'
- source: '                            { int Max_Value =  what_was_just_output.size() ; for (int LoopNumber=1; LoopNumber <= Max_Value ; LoopNumber++) {'
- source: '                                if (what_was_just_output[what_was_just_output.size() - LoopNumber] != ''\n'')'
- source: '                                    {'
- source: '                                        charaters_till_newline++;'
- source: '                                    }'
- source: '                                else '
- source: '                                    {'
- source: '                                        break;'
- source: '                                    }'
- source: '                            } }'
- source: '                            return charaters_till_newline;'
- source: '                        }'
- source: '            public:'
- source: '                void reset()'
- source: '                    {'
- source: '                        length_of_last_line = 0;'
- source: '                        dont_go_up_a_line = true;'
- source: '                        what_was_just_output = "";'
- source: '                    }'
- source: '                void output_line()'
- source: '                    {'
- source: '                        if (dont_go_up_a_line)'
- source: '                            {'
- source: '                                save_cursor_position();'
- source: '                                for (auto each : content)'
- source: '                                    {'
- source: '                                        if (each == ''\n'')'
- source: '                                            {'
- source: '                                                cout << __OUTPUT_INDENT;'
- source: '                                            }'
- source: '                                        cout << each;'
- source: '                                    }'
- source: '                                cout << "\n";'
- source: '                                __INCREASE_INDENT = false;'
- source: '                                dont_go_up_a_line = false;'
- source: '                            }'
- source: '                        else'
- source: '                            {'
- source: '                                go_up_a_line();'
- source: '                                length_of_last_line += length_of_previous_line();'
- source: '                                go_to_the_right(length_of_last_line);'
- source: '                                for (auto each : content)'
- source: '                                    {'
- source: '                                        if (each == ''\n'')'
- source: '                                            {'
- source: '                                                cout << __OUTPUT_INDENT;'
- source: '                                            }'
- source: '                                        cout << each;'
- source: '                                    }'
- source: '                                // FIXME, if the terminal width is really small '
- source: '                                // and the string is really long, this might mess things up '
- source: '                            }'
- source: '                        restore_cursor_position();'
- source: '                    }'
- source: '                void add_content(string input_)'
- source: '                    {'
- source: '                        what_was_just_output = content;'
- source: '                        content = input_;'
- source: '                    }'
- source: '        };'
- source: '    stringstream __PutsOutputFixerStream;'
- source: '    __PutLinesOutputFixerStreamClass __PutLinesOutputFixerStream;'
- source: '    __PutLinesOutputFixerStreamClass __LogOutputFixerStream;'
- source: '    // for normal input (classes)'
- source: '    template<class ANYTYPE>'
- source: '    inline ostream& operator,(ostream& o, const ANYTYPE& value) '
- source: '        {'
- source: '            // if its the puts stream then output each thing with a newline after it'
- source: '            if (&o == &__PutsOutputFixerStream)'
- source: '                {'
- source: '                    // make this threadsafe by only allowing one printout at a time'
- source: '                    pthread_mutex_lock(&mutex_for_output);'
- source: '                    // put the value into the string stream '
- source: '                    stringstream converter_to_string;'
- source: '                    converter_to_string << value;'
- source: '                    // get the output as a string'
- source: '                    string content_being_output = converter_to_string.str();'
- source: '                    // insert the indent at the begining'
- source: '                    cout << __OUTPUT_INDENT;'
- source: '                    // insert the indent after every newline in the content'
- source: '                    for (auto each_char : content_being_output)'
- source: '                        {'
- source: '                            if (each_char == ''\n'')'
- source: '                                {'
- source: '                                    cout << __OUTPUT_INDENT;'
- source: '                                }'
- source: '                            cout << each_char;'
- source: '                        }'
- source: '                    // send a newline at the end'
- source: '                    cout << "\n";'
- source: '                    // unlock the mutex to allow other threads to print things out;'
- source: '                    pthread_mutex_unlock(&mutex_for_output);'
- source: '                }'
- source: '            // if its the __PutLinesOutputFixerStream, then use __PutLinesOutputFixerStream to output'
- source: '            else if (&o == &__PutLinesOutputFixerStream)'
- source: '                {'
- source: '                    // erase the string-stream part of __PutLinesOutputFixerStream'
- source: '                    __PutLinesOutputFixerStream.str("");'
- source: '                    // add the line to __PutLinesOutputFixerStream'
- source: '                    stringstream out_stream;'
- source: '                    out_stream << value;'
- source: '                    __PutLinesOutputFixerStream.add_content(__OUTPUT_INDENT + out_stream.str());'
- source: '                    // output the line '
- source: '                    __PutLinesOutputFixerStream.output_line();'
- source: '                }'
- source: '            // if its the Debugging_stream'
- source: '            else if (&o == &__LogOutputFixerStream)'
- source: '                {'
- source: '                    // erase the string-stream part of __PutLinesOutputFixerStream'
- source: '                    __LogOutputFixerStream.str("");'
- source: '                    // check if Debugging is on '
- source: '                    if (Debugging == true)'
- source: '                        {'
- source: '                            // add the line to __LogOutputFixerStream'
- source: '                            stringstream out_stream;'
- source: '                            out_stream << value;'
- source: '                            if (__INCREASE_INDENT == true)'
- source: '                                {'
- source: '                                    __LogOutputFixerStream.add_content(__OUTPUT_INDENT + out_stream.str());'
- source: '                                    __OUTPUT_INDENT += "    ";'
- source: '                                }'
- source: '                            else '
- source: '                                {'
- source: '                                    __LogOutputFixerStream.add_content(__OUTPUT_INDENT + out_stream.str());'
- source: '                                }'
- source: '                            // output the line '
- source: '                            __LogOutputFixerStream.output_line();'
- source: '                        }'
- source: '                    else '
- source: '                        {'
- source: '                            // dont output anything '
- source: '                            o << "";'
- source: '                        }'
- source: '                } // end if debugging'
- source: '            // if it''s some other stream'
- source: '            else'
- source: '                {'
- source: '                    // then just keep going like normal'
- source: '                    stringstream out_stream;'
- source: '                    out_stream << value;'
- source: '                    o << out_stream.str();'
- source: '                }'
- source: '            return o;'
- source: '        }'
- source: '    // for stream operators (fixed, setprecision(), etc)'
- source: '    inline ostream& operator,(ostream& o, ostream& (*manip_fun)(ostream&)) '
- source: '        {'
- source: '            // if its from print, then use then send it to cout directly '
- source: '            if (&o == &__PutLinesOutputFixerStream)'
- source: '                {'
- source: '                    cout << manip_fun;'
- source: '                }'
- source: '            else if (&o == &__LogOutputFixerStream)'
- source: '                {'
- source: '                    if (Debugging == true)'
- source: '                        {'
- source: '                            cout << manip_fun;'
- source: '                        }'
- source: '                }'
- source: '            // if it''s some other stream'
- source: '            else'
- source: '                {'
- source: '                    // then just keep going like normal'
- source: '                    o << manip_fun;'
- source: '                }'
- source: '            return o;'
- source: '        }'
- source: '#endif '
