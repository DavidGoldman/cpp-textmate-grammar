- source: '#include <iostream>'
- source: '#include <sstream>'
- source: //
- source: //
- source: // Constants
- source: //
- source: //
- source: '    //'
- source: '    // Digits'
- source: '    //'
- source: '        // decimal'
- source: '            1'
- source: '            .1'
- source: '            .239480'
- source: '            .239480f'
- source: '            0.'
- source: '            0.f'
- source: '            0.L'
- source: '            0.LL'
- source: '            4897430la'
- source: '            32094.930123a'
- source: '            4897430LL'
- source: '            32094.930123F'
- source: '            32094.930123f'
- source: '            1''03''432''43'
- source: '            123232''1231321'
- source: '            3''20''94.93''01''23'
- source: '            3''20''94.93''1''23'
- source: '        // e'
- source: '            0e1'
- source: '            1e10f'
- source: '            1.e10'
- source: '            1.e10'
- source: '            1.e-10'
- source: '            1.79769e+308'
- source: '            1.79''76''9e+3''0''8'
- source: '        // octal'
- source: '            01'
- source: '            01001202'
- source: '            010''0''120''2'
- source: '            0''1''2''3''4'
- source: '        // binary'
- source: '            0b101010'
- source: '            0b000001'
- source: '            0b100001'
- source: '            0b1''01''010'
- source: '            0b1''00''001'
- source: '        // hex'
- source: '            0x01'
- source: '            0xabcdef'
- source: '            0xaBCDEf'
- source: '            0xABCDEF'
- source: '            0xAB.cdp5f'
- source: '            0xAB.cdp5l'
- source: '            0x20394afLL'
- source: '            0x01'
- source: '            0xabc''def'
- source: '            0xa''BC''DEf'
- source: '            0xABC''DEF'
- source: '            0x20''394''a''fLL'
- source: '        // hex floating point literal'
- source: '            0x0.5p10F'
- source: '            0x0.5p10f'
- source: '            0x1ffp10'
- source: '            0x0.23p10'
- source: '            0x0.234985p10L'
- source: '            0x139804.234985p10L'
- source: '            0x0.53''84''92p10'
- source: '            0x5.p10'
- source: '            0x0.23p+10'
- source: '            0x0.234985p+10L'
- source: '            0x139804.234985p-10L'
- source: '            0x0.53''84''92p-10'
- source: '            0x5.p+10'
- source: '            0x13''98''04.234985p10L'
- source: '        // custom literals'
- source: '            29042ms'
- source: '            0xabcdefmm'
- source: '            0xabc''defmm'
- source: '            0xabcdefyards'
- source: '            20ounces'
- source: '            2000miles'
- source: '            L"akdjfhald"'
- source: '        // invalid literals'
- source: '            1Ex'
- source: '            0xe+foo'
- source: '            0x1Px'
- source: '            0xAB.cdpfl'
- source: '            0x12345''luyards'
- source: '            0.''123'
- source: '            0''.123'
- source: '            1E''1'
- source: '            1''E1'
- source: '        // odd valid literals'
- source: '            0x12345luyards'
- source: '            0''12345'
- source: '            0x1Ex'
- source: '            1Px'
- source: '    //'
- source: '    // chars'
- source: '    //'
- source: '        ''1'''
- source: '        ''a'''
- source: '        ''\n'''
- source: '        ''\0'''
- source: '    //'
- source: '    // Strings'
- source: '    //'
- source: '        auto a = "things\n\b\v\t";'
- source: '// '
- source: // operator words
- source: '// '
- source: '    auto a = 1 and 1;'
- source: '    auto a = 1 or 1;'
- source: '    auto a = 1 xor 1;'
- source: //
- source: // type castings
- source: //
- source: '    dynamic_cast <int> (expression + 1 + thing);'
- source: '    reinterpret_cast <double> (expression);'
- source: '    static_cast <Custom> (expression);'
- source: '    const_cast <int> (expression);'
- source: '    {'
- source: '        dynamic_cast <int> (expression + 1 + thing);'
- source: '        reinterpret_cast <double> (expression);'
- source: '        static_cast <Custom> (expression);'
- source: '        const_cast <int> (expression);'
- source: '    }'
- source: //
- source: // Storage types
- source: //
- source: '    pthread_rwlockattr_t thing;'
- source: '    pthread_rwlockattr_t thing;'
- source: '    decltype(int);'
- source: '// '
- source: '// operators '
- source: '// '
- source: '    typeid()'
- source: '    sizeof()'
- source: '    alignas()'
- source: //
- source: // Memory
- source: //
- source: '    auto a = new int(5);'
- source: '    delete a;'
- source: '    new (&a_storage_of_callable.callable) type(forward<Callable>(a_callable));'
- source: '    int *array = new int[100];'
- source: '    delete[] array;'
- source: '    char should_always_be_a_newline;'
- source: '    char deleter;'
- source: //
- source: //
- source: // namespaces
- source: //
- source: //
- source: '    using namespace std;'
- source: '    using namespace std;using namespace std;'
- source: '    using namespace parent_namespace::std;'
- source: '    inline namespace {};'
- source: '    namespace {};'
- source: '    namespace scoped::console { };'
- source: '    namespace console {'
- source: '        template <typename ANYTYPE> void __MAGIC__show(ANYTYPE input) {'
- source: '                // by default use the stream operator with cout'
- source: '                std::cout << input;'
- source: '            }'
- source: '    }'
- source: '// '
- source: // Scope resolution
- source: //
- source: '    std::cout << input;'
- source: '    numeric_limits<long double>::infinity();'
- source: '    char_traits<ANYTYPE>::eof();'
- source: '    numeric_limits<streamsize>::max();'
- source: '    Task<ANY_OUTPUT_TYPE, ANY_INPUT_TYPE>::links_to;'
- source: '    &TEST_CLASS::name;'
- source: '    Event<ANYTYPE>::   ListenersFor[input_event.name]'
- source: '    std::allocator_traits<decltype(acopy)>::destroy(acopy, this);'
- source: '    std::allocator_traits<decltype(acopy)>::deallocate(acopy, this);'
- source: //
- source: // member access
- source: //
- source: '    window.as.translate(0,0.5,0);'
- source: '    window.MV.translate(0,0.5,0);'
- source: '    a_pointer.thread;'
- source: '    a_pointer.*thread;'
- source: '    a_pointer->thread;'
- source: '    a_pointer->*thread;'
- source: '    a_pointer.thread.thing;'
- source: '    a_pointer.*thread.*thing;'
- source: '    a_pointer->thread->thing;'
- source: '    a_pointer->*thread->*thing;'
- source: '    a_pointer.thread->*thing;'
- source: '    a_pointer.*thread->thing;'
- source: '    a_pointer->thread.*thing;'
- source: '    a_pointer->*thread.thing;'
- source: '    a_pointer.thread[0];'
- source: '    a_pointer.*thread[0];'
- source: '    a_pointer->thread[0];'
- source: '    a_pointer->*thread[0];'
- source: '    a_pointer.thread[0]->*thing;'
- source: '    a_pointer.*thread[0]->thing;'
- source: '    a_pointer->thread[0].*thing;'
- source: '    a_pointer->*thread[0].thing;'
- source: '    a_pointer.thread();'
- source: '    a_pointer.*thread();'
- source: '    ptr_to_original->Start();'
- source: '    ptr_to_original->*Start();'
- source: '    a_pointer.thread()->*thing;'
- source: '    a_pointer.*thread()->thing;'
- source: '    ptr_to_original->Start().*thing;'
- source: '    ptr_to_original->*Start().thing;'
- source: '    {'
- source: '        a_pointer.thread[0]->*thing;'
- source: '        a_pointer.*thread[0]->thing;'
- source: '        a_pointer->thread[0].*thing;'
- source: '        a_pointer->*thread[0].thing;'
- source: '        a_pointer.thread;'
- source: '        a_pointer.*thread;'
- source: '        a_pointer->thread;'
- source: '        a_pointer->*thread;'
- source: '    }'
- source: '    {'
- source: '        a_pointer.thread();'
- source: '        a_pointer.*thread();'
- source: '        ptr_to_original->Start();'
- source: '        ptr_to_original->*Start();'
- source: '    }'
- source: //
- source: // Operator keyword
- source: //
- source: '    ostream& operator<<(ostream& out, const Item& input_) {};'
- source: '    Item  operator+( const string&  base        , const int&    repetitions ) {};'
- source: '    Item  operator-( const int&     the_input   , const Item&   input_item  ) {};'
- source: '    Item  operator/( const Item&    input_item  , const int&    the_input   ) {};'
- source: '    Item  operator^( const Item&    input_item  , const int&    the_input   ) {};'
- source: '    // implicit conversions'
- source: '    operator std::string() const {};'
- source: '    operator double() const {};'
- source: '    // custom literal'
- source: '    void operator "" _km(long double);'
- source: //
- source: //
- source: // preprocessor
- source: //
- source: //
- source: '    #define Infinite    numeric_limits<long double>::infinity()'
- source: '    #define DoubleMax   1.79769e+308'
- source: '    #define Pi          3.1415926535897932384626'
- source: '    #define show(argument) cout << #argument << "\n";'
- source: '    #ifndef CEKO_LIBRARY'
- source: '    #define CEKO_LIBRARY'
- source: '    #endif'
- source: //
- source: // templates
- source: //
- source: '    void func() {'
- source: '        std::cout << max<int>(a, b) << std::endl;'
- source: '        std::cout << max(a, b) << std::endl;'
- source: '    }'
- source: '    namespace test {'
- source: '        template <class T>'
- source: '        #ifdef blah'
- source: '        struct test '
- source: '        #endif'
- source: '        {'
- source: '            // seperate line template'
- source: '            template <class U = std::vector<int>>'
- source: '            template<typename RETURN_TYPE, int N = 0 > 1, typename Callable> '
- source: '            bool operator()(U k) {}'
- source: '        };'
- source: '        struct test2 {'
- source: '            // same-line template'
- source: '            template <class U = std::vector<int>>  bool operator()(U k) {}'
- source: '        };'
- source: '        struct test3 {'
- source: '            // same-line template'
- source: '            template <class U = std::vector<int>>  bool operator()(U k) {}'
- source: '        };'
- source: '        struct test2 {'
- source: '            bool operator()() = delete;'
- source: '        };'
- source: '    } // namespace test'
- source: '    // no syntax highlighting'
- source: '    class test2 {};'
- source: '    template<int, typename Callable, typename Ret, typename... Args>'
- source: '    auto internalConversionToFuncPtr(Callable&& a_callable, Ret (*)(Args...))'
- source: '        {'
- source: '            static bool used = false;'
- source: '            static storage<Callable> a_storage_of_callable;'
- source: '            using type = decltype(a_storage_of_callable.callable);'
- source: '            if(used) {'
- source: '                a_storage_of_callable.callable.~type();'
- source: '            }'
- source: '            new (&a_storage_of_callable.callable) type(forward<Callable>(a_callable));'
- source: '            used = true;'
- source: '            // lambda '
- source: '            return [](Args... args) -> Ret {'
- source: '                return Ret(a_storage_of_callable.callable(forward<Args>(args)...));'
- source: '            };'
- source: '        }'
- source: '        template<typename RETURN_TYPE, int N = 0, typename Callable>'
- source: '        RETURN_TYPE* convertToFunctionPointer(Callable&& c)'
- source: '            {'
- source: '                return internalConversionToFuncPtr<N>(forward<Callable>(c), (RETURN_TYPE*)nullptr);'
- source: '            }'
- source: '// '
- source: // Classes
- source: //
- source: '    class Thing {'
- source: '        public:'
- source: '        public :'
- source: '        private :'
- source: '        private:'
- source: '        protected:'
- source: '            auto a = 1;'
- source: '            Thing() {'
- source: '            }'
- source: '    };'
- source: '    struct Thing2 {'
- source: '        public:'
- source: '        public :'
- source: '        private :'
- source: '        private:'
- source: '        protected:'
- source: '            auto a = 1;'
- source: '            Thing() {'
- source: '            }'
- source: '    };'
- source: '    class A{'
- source: '        void A();'
- source: '    };'
- source: '    class A'
- source: '{'
- source: '        void A();'
- source: '};'
- source: '    class A {'
- source: '        void A();'
- source: '    };'
- source: '    class A'
- source: '{'
- source: '      void A();'
- source: '};'
- source: "\tclass ClassA {"
- source: '};'
- source: "\tclass ClassE final : public ClassA {"
- source: "\t};"
- source: "\tnamespace foo {"
- source: "\t\tclass ClassF {"
- source: "\t};"
- source: "\tclass ClassG {"
- source: "\t};"
- source: '}'
- source: 'class ClassH : public foo::ClassF, public foo::ClassG {'
- source: '};'
- source: '    class foo : bar {};'
- source: '    class foo : public bar {};'
- source: '    struct copy_storage_helper<pointerT, hashT, allocatorT, false>     // copyableT'
- source: '      {'
- source: '        [[noreturn]] void operator()(pointerT /*ptr*/, const hashT& /*hf*/, pointerT /*ptr_old*/, size_t /*off*/, size_t /*cnt*/) const'
- source: '          {'
- source: '            // `allocatorT::value_type` is not copy-constructible.'
- source: '            // Throw an exception unconditionally, even when there is nothing to copy.'
- source: '            noadl::sprintf_and_throw<domain_error>("cow_hashmap: `%s` is not copy-constructible.",'
- source: '                                                   typeid(typename allocatorT::value_type).name());'
- source: '          }'
- source: '      };'
- source: '// '
- source: // enums
- source: '// '
- source: '    enum{ thing };'
- source: '    enum {};'
- source: '    enum A {'
- source: '        a, b'
- source: '    };'
- source: '    enum enum1'
- source: '        {'
- source: '            // comment'
- source: '            definition /* block comment */, definition3'
- source: '            definition, definition2 // comment'
- source: '        }'
- source: '// '
- source: // inheritance
- source: '// '
- source: '    class foo : private bar,quix,foo, public bar, quix, foo, protected bar, quix{};'
- source: '    struct foo f;'
- source: '    class foo f;'
- source: '    struct thing : '
- source: '        public A, public B {};'
- source: '    class thing :'
- source: '        public A,'
- source: '        public B,'
- source: '        {};'
- source: '// '
- source: // Functions
- source: '// '
- source: '    template <class ANYTYPE>'
- source: '    string ToBinary(ANYTYPE input)'
- source: '        {'
- source: '            // depends on #include <bitset>'
- source: '            return bitset<8>(input).to_string();'
- source: '        }'
- source: //
- source: // lambdas
- source: //
- source: '    auto a = [ a, b, c ] '
- source: '    (Args... args, int thing1) -> Ret '
- source: '        {'
- source: '        }'
- source: '    [ a,                     b, c ] (Args... args, int thing1) mutable -> Ret {         }'
- source: '    [ a,                     b, c ] (Args... args, int thing1)                {         }'
- source: '    [ a = stuff::blah[1324], b, c ] (Args... args, int thing1)                {         }'
- source: '    [ a,                     b, c ]                                           {         }'
- source: '    [=]                                                                -> int {         }'
- source: '    [=]                             ()                         mutable        { return; }'
- source: '    auto a = thing[1][2];'
- source: '    auto a = thing()[2];'
- source: '    [](Args... args) -> Ret {'
- source: '                return Ret(a_storage_of_callable.callable(forward<Args>(args)...));'
- source: '            };'
- source: '    return [ a, b, c ] (Args... args, int thing1) -> Ret { }'
- source: '    return [ a, b, c ] -> int { }'
- source: '    //'
- source: '    // not lambdas'
- source: '    //'
- source: '    test()[0] = 5; // no syntax highlighting;'
- source: '    test[5][5] = 5;'
- source: 'int main() {'
- source: '    int a = ( thing + 10)'
- source: '    return 0;'
- source: '}'
- source: //
- source: // Attributes
- source: //
- source: '    switch (test) {'
- source: '        case 1:'
- source: '        break;'
- source: '        case 2: [[fallthrough]];'
- source: '        case 3: break; // no syntax highlighting'
- source: '    }'
- source: '    switch(next) {'
- source: '        case ''\'''':'
- source: '        case ''\"'':'
- source: '        case ''\\'':'
- source: '        case ''?'':'
- source: '            {'
- source: '            value.push_back(next);'
- source: '            break;'
- source: '            }'
- source: '        case ''a'':'
- source: '            {'
- source: '            value.push_back(''\a'');'
- source: '            break;'
- source: '            }'
- source: '        case ''b'':'
- source: '            {'
- source: '            value.push_back(''\b'');'
- source: '            break;'
- source: '            }'
- source: '        case ''f'':'
- source: '            {'
- source: '            value.push_back(''\f'');'
- source: '            break;'
- source: '            }'
- source: '        case ''n'':'
- source: '            {'
- source: '            value.push_back(''\n'');'
- source: '            break;'
- source: '            }'
- source: '        case ''r'':'
- source: '            {'
- source: '            value.push_back(''\r'');'
- source: '            break;'
- source: '            }'
- source: '        case ''t'':'
- source: '            {'
- source: '            value.push_back(''\t'');'
- source: '            break;'
- source: '            }'
- source: '        case ''v'':'
- source: '            {'
- source: '            value.push_back(''\v'');'
- source: '            break;'
- source: '            }'
- source: '        case ''0'':'
- source: '            {'
- source: '            value.push_back(''\0'');'
- source: '            break;'
- source: '            }'
- source: '        case ''Z'':'
- source: '            {'
- source: '            value.push_back(''\x1A'');'
- source: '            break;'
- source: '            }'
- source: '        case ''e'':'
- source: '            {'
- source: '            value.push_back(''\x1B'');'
- source: '            break;'
- source: '            }'
- source: '        case ''U'':'
- source: '            {'
- source: '            xcnt += 2;  // 6: "\U123456"'
- source: '            }'
- source: '            // Fallthrough.'
- source: '        case ''u'':'
- source: '            {'
- source: '            xcnt += 2;  // 4: "\u1234"'
- source: '            }'
- source: '            // Fallthrough.'
- source: '        case ''x'':'
- source: '            {'
- source: '            xcnt += 2;  // 2: "\x12"'
- source: '            // Read hex digits.'
- source: '            if(qavail < xcnt + 2) {'
- source: '                throw do_make_parser_error(reader, reader.size_avail(), Parser_Error::code_escape_sequence_incomplete);'
- source: '            }'
- source: '            char32_t cpnt = 0;'
- source: '            for(auto i = tlen; i < tlen + xcnt; ++i) {'
- source: '                static constexpr char s_digits[] = "00112233445566778899AaBbCcDdEeFf";'
- source: '                auto dptr = std::char_traits<char>::find(s_digits, 32, bptr[i]);'
- source: '                if(!dptr) {'
- source: '                throw do_make_parser_error(reader, i + 1, Parser_Error::code_escape_sequence_invalid_hex);'
- source: '                }'
- source: '                auto dvalue = static_cast<char32_t>((dptr - s_digits) / 2);'
- source: '                cpnt = cpnt * 16 + dvalue;'
- source: '            }'
- source: '            if(next == ''x'') {'
- source: '                // Write the character verbatim.'
- source: '                value.push_back(static_cast<char>(cpnt));'
- source: '                break;'
- source: '            }'
- source: '            // Write a Unicode code point.'
- source: '            if(((0xD800 <= cpnt) && (cpnt < 0xE000)) || (0x110000 <= cpnt)) {'
- source: '                // Code point value is reserved or too large.'
- source: '                throw do_make_parser_error(reader, tlen + xcnt, Parser_Error::code_escape_utf_code_point_invalid);'
- source: '            }'
- source: '            // Encode it.'
- source: '            auto encode_one = [&](unsigned shift, unsigned mask)'
- source: '                {'
- source: '                value.push_back(static_cast<char>((~mask << 1) | ((cpnt >> shift) & mask)));'
- source: '                };'
- source: '            if(cpnt < 0x80) {'
- source: '                encode_one( 0, 0xFF);'
- source: '                break;'
- source: '            }'
- source: '            if(cpnt < 0x800) {'
- source: '                encode_one( 6, 0x1F);'
- source: '                encode_one( 0, 0x3F);'
- source: '                break;'
- source: '            }'
- source: '            if(cpnt < 0x10000) {'
- source: '                encode_one(12, 0x0F);'
- source: '                encode_one( 6, 0x3F);'
- source: '                encode_one( 0, 0x3F);'
- source: '                break;'
- source: '            }'
- source: '            encode_one(18, 0x07);'
- source: '            encode_one(12, 0x3F);'
- source: '            encode_one( 6, 0x3F);'
- source: '            encode_one( 0, 0x3F);'
- source: '            break;'
- source: '            }'
- source: '        default:'
- source: '            thing;'
- source: '        }'
- source: '    void func1();'
- source: '    [[noreturn]] void func2(/*syntax highlighting*/); // no syntax highlighting'
- source: '    struct st { // syntax highlighting works now'
- source: '    };'
- source: '    void func3();'
- source: // Universal character name
- source: 'class LineReader{};'
- source: 'class Line_Reader{};'
- source: 'class Line\u00b7Reader{};'
- source: 'class Line\U0002070EReader{};'
