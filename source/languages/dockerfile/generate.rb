require_relative '../../../directory'
require_relative PathFor[:repo_helper]
require_relative PathFor[:textmate_tools]
require_relative PathFor[:sharedPattern]["numeric"]
require_relative PathFor[:sharedPattern]["variable"]
require_relative './tokens.rb'

# 
# Setup grammar
# 
    Dir.chdir __dir__
    original_grammar = JSON.parse(IO.read("original.tmlanguage.json"))
    Grammar.convertSpecificIncludes(json_grammar: original_grammar, convert:["$self", "$base"], into: :$initial_context)
    grammar = Grammar.new(
        name: original_grammar["name"],
        scope_name: original_grammar["scopeName"],
        file_types: [
            "dockerfile",
        ],
        version: "",
        information_for_contributors: [
            "This code was auto generated by a much-more-readble ruby file",
            "see https://github.com/jeff-hykin/cpp-textmate-grammar/blob/master",
        ],
    )

#
#
# Contexts
#
#
    grammar[:$initial_context] = [
            :multiline_run_statement,
            newPattern(
                match: /.+/,
                tag_as: "entity"
            ),
            # import all the original patterns
            # *original_grammar["patterns"],
        ]
#
#
# Patterns
#
#
    # copy over all the repos
    for each_key, each_value in original_grammar["repository"] || []
        grammar[each_key.to_sym] = each_value
    end
    
    # pull in the entire shell syntax
    grammar[:shell] = JSON.parse(IO.read(PathFor[:jsonSyntax]["shell"]))
    # allow the command call to have a word infront of it
    grammar[:shell]["repository"]["command_call"]["begin"] = "(?<=(?:^|;|\\||&|!|\\(|\\{|\\`|\\A|\\G))\\s*+(?!function\\W|function\\$|select\\W|select\\$|case\\W|case\\$|do\\W|do\\$|done\\W|done\\$|elif\\W|elif\\$|else\\W|else\\$|esac\\W|esac\\$|fi\\W|fi\\$|for\\W|for\\$|if\\W|if\\$|in\\W|in\\$|then\\W|then\\$|until\\W|until\\$|while\\W|while\\$|alias\\W|alias\\$|bg\\W|bg\\$|command\\W|command\\$|false\\W|false\\$|fc\\W|fc\\$|fg\\W|fg\\$|getopts\\W|getopts\\$|hash\\W|hash\\$|jobs\\W|jobs\\$|kill\\W|kill\\$|newgrp\\W|newgrp\\$|read\\W|read\\$|true\\W|true\\$|umask\\W|umask\\$|unalias\\W|unalias\\$|wait\\W|wait\\$)"
    
    # grammar[:shell]["patterns"] = [
    #     { "include" => "#initial_context" }
    # ]
    grammar[:multiline_run_statement] = PatternRange.new(
        tag_content_as: "meta.command.run",
        start_pattern: newPattern(
            newPattern(
                match: variableBounds(/RUN/),
                tag_as: "keyword.other.special-method",
            # look to make sure the line gets extended at the end with a \
            ).lookAheadFor(/.+\\$/)
        ),
        # while the line is beging extended with \
        while: lookAheadFor(/^.+\\$/).maybe(
            match: /.+?libavcodec-dev/,
            tag_as: "storage.type"
        ),
        end_pattern: /.+/,
        apply_end_pattern_last: "1",
        includes: [
            # :shell,
            PatternRange.new(
                tag_as: "meta.inner",
                start_pattern: newPattern(
                    match: /pkg-config/,
                    tag_as: "keyword.other.begin",
                ),
                end_pattern: newPattern(
                    match: /libx264-dev/,
                    tag_as: "keyword.other.end",
                ),
            ),
            newPattern(
                match: /./,
                tag_as: "entity.name.test"
            ),
        ]
    )
 
# Save
saveGrammar(grammar)