information_for_contributors: [
	"This file has been converted from https://github.com/atom/language-c/blob/master/grammars/c.cson"
	"If you want to provide a fix or improvement, please create a pull request against the original repository."
	"Once accepted there, we are happy to receive an update request."
]
version: "https://github.com/atom/language-c/commit/9c0c5f202741a5647025db8d5df5fefba47b036c"
name: "C"
scopeName: "source.c"
patterns: [
	{
		include: "#preprocessor-rule-enabled"
	}
	{
		include: "#preprocessor-rule-disabled"
	}
	{
		include: "#preprocessor-rule-conditional"
	}
	{
		include: "#comments"
	}
	{
		match: "\\b(break|case|continue|default|do|else|for|goto|if|_Pragma|return|switch|while)\\b"
		name: "keyword.control.c"
	}
	{
		include: "#storage_types"
	}
	{
		match: "\\b(const|extern|register|restrict|static|volatile|inline)\\b"
		name: "storage.modifier.c"
	}
	{
		match: "\\bk[A-Z]\\w*\\b"
		name: "constant.other.variable.mac-classic.c"
	}
	{
		match: "\\bg[A-Z]\\w*\\b"
		name: "variable.other.readwrite.global.mac-classic.c"
	}
	{
		match: "\\bs[A-Z]\\w*\\b"
		name: "variable.other.readwrite.static.mac-classic.c"
	}
	{
		match: "\\b(NULL|true|false|TRUE|FALSE)\\b"
		name: "constant.language.c"
	}
	{
		include: "#operators"
	}
	{
		include: "#operator_overload"
	}
	{
		include: "#numbers"
	}
	{
		include: "#strings"
	}
	{
		begin: '''
			(?x)
			^\\s* ((\\#)\\s*define) \\s+	# define
			((?<id>[a-zA-Z_$][\\w$]*))	  # macro name
			(?:
			  (\\()
				(
				  \\s* \\g<id> \\s*		 # first argument
				  ((,) \\s* \\g<id> \\s*)*  # additional arguments
				  (?:\\.\\.\\.)?			# varargs ellipsis?
				)
			  (\\))
			)?
		'''
		beginCaptures:
			"1":
				name: "keyword.control.directive.define.c"
			"2":
				name: "punctuation.definition.directive.c"
			"3":
				name: "entity.name.function.preprocessor.c"
			"5":
				name: "punctuation.definition.parameters.begin.c"
			"6":
				name: "variable.parameter.preprocessor.c"
			"8":
				name: "punctuation.separator.parameters.c"
			"9":
				name: "punctuation.definition.parameters.end.c"
		end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)"
		name: "meta.preprocessor.macro.c"
		patterns: [
			{
				include: "#preprocessor-rule-define-line-contents"
			}
		]
	}
	{
		begin: '^\\s*((#)\\s*(error|warning))\\b\\s*'
		beginCaptures:
			1:
				name: 'keyword.control.directive.diagnostic.$3.c'
			2:
				name: 'punctuation.definition.directive.c'
		end: '(?<!\\\\)(?=\\n)'
		name: 'meta.preprocessor.diagnostic.c'
		patterns: [
			{
				# double quoted string patterns for #error/warning lines (terminates at newline w/o line_continuation_character)
				begin: '"'
				beginCaptures:
					'0':
						'name': 'punctuation.definition.string.begin.c'
				end: '"|(?<!\\\\)(?=\\s*\\n)'
				endCaptures:
					'0':
						'name': 'punctuation.definition.string.end.c'
				name: 'string.quoted.double.c'
				patterns: [
					{
						'include': '#line_continuation_character'
					}
				]
			}
			{
				# single quoted string patterns for #error/warning lines (terminates at newline w/o line_continuation_character)
				begin: '\''
				beginCaptures:
                    0:
                        name: 'punctuation.definition.string.begin.c'
				end: '\'|(?<!\\\\)(?=\\s*\\n)'
				endCaptures:
                    0:
                        name: 'punctuation.definition.string.end.c'
				name: 'string.quoted.single.c'
				patterns: [
					{
						include: '#line_continuation_character'
					}
				]
			}
			{
				# unquoted strings patterns for #error/warning lines (terminates at newline w/o line_continuation_character)
				begin: '[^\'"]'
				end: '(?<!\\\\)(?=\\s*\\n)'
				name: 'string.unquoted.single.c'
				patterns: [
					{
						include: '#line_continuation_character'
					}
					{
						include: '#comments'
					}
				]
			}
		]
	}
	{
		begin: "^\\s*((#)\\s*(include(?:_next)?|import))\\b\\s*"
		beginCaptures:
			"1":
				name: "keyword.control.directive.$3.c"
			"2":
				name: "punctuation.definition.directive.c"
		end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)"
		name: "meta.preprocessor.include.c"
		patterns: [
			{
				include: "#line_continuation_character"
			}
			{
				begin: "\""
				beginCaptures:
					"0":
						name: "punctuation.definition.string.begin.c"
				end: "\""
				endCaptures:
					"0":
						name: "punctuation.definition.string.end.c"
				name: "string.quoted.double.include.c"
			}
			{
				begin: "<"
				beginCaptures:
					"0":
						name: "punctuation.definition.string.begin.c"
				end: ">"
				endCaptures:
					"0":
						name: "punctuation.definition.string.end.c"
				name: "string.quoted.other.lt-gt.include.c"
			}
		]
	}
	{
		include: "#pragma-mark"
	}
	{
		begin: "^\\s*((#)\\s*line)\\b"
		beginCaptures:
			"1":
				name: "keyword.control.directive.line.c"
			"2":
				name: "punctuation.definition.directive.c"
		end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)"
		name: "meta.preprocessor.c"
		patterns: [
			{
				include: "#strings"
			}
			{
				include: "#numbers"
			}
			{
				include: "#line_continuation_character"
			}
		]
	}
	{
		begin: "^\\s*(?:((#)\\s*undef))\\b"
		beginCaptures:
			"1":
				name: "keyword.control.directive.undef.c"
			"2":
				name: "punctuation.definition.directive.c"
		end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)"
		name: "meta.preprocessor.c"
		patterns: [
			{
				match: "[a-zA-Z_$][\\w$]*"
				name: "entity.name.function.preprocessor.c"
			}
			{
				include: "#line_continuation_character"
			}
		]
	}
	{
		begin: "^\\s*(?:((#)\\s*pragma))\\b"
		beginCaptures:
			"1":
				name: "keyword.control.directive.pragma.c"
			"2":
				name: "punctuation.definition.directive.c"
		end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)"
		name: "meta.preprocessor.pragma.c"
		patterns: [
			{
				include: "#strings"
			}
			{
				match: "[a-zA-Z_$][\\w\\-$]*"
				name: "entity.other.attribute-name.pragma.preprocessor.c"
			}
			{
				include: "#numbers"
			}
			{
				include: "#line_continuation_character"
			}
		]
	}
	{
		match: "\\b(u_char|u_short|u_int|u_long|ushort|uint|u_quad_t|quad_t|qaddr_t|caddr_t|daddr_t|div_t|dev_t|fixpt_t|blkcnt_t|blksize_t|gid_t|in_addr_t|in_port_t|ino_t|key_t|mode_t|nlink_t|id_t|pid_t|off_t|segsz_t|swblk_t|uid_t|id_t|clock_t|size_t|ssize_t|time_t|useconds_t|suseconds_t)\\b"
		name: "support.type.sys-types.c"
	}
	{
		match: "\\b(pthread_attr_t|pthread_cond_t|pthread_condattr_t|pthread_mutex_t|pthread_mutexattr_t|pthread_once_t|pthread_rwlock_t|pthread_rwlockattr_t|pthread_t|pthread_key_t)\\b"
		name: "support.type.pthread.c"
	}
	{
		match: '''
			(?x) \\b
			(int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|int_least8_t
			|int_least16_t|int_least32_t|int_least64_t|uint_least8_t|uint_least16_t|uint_least32_t
			|uint_least64_t|int_fast8_t|int_fast16_t|int_fast32_t|int_fast64_t|uint_fast8_t
			|uint_fast16_t|uint_fast32_t|uint_fast64_t|intptr_t|uintptr_t|intmax_t|intmax_t
			|uintmax_t|uintmax_t)
			\\b
		'''
		name: "support.type.stdint.c"
	}
	{
		match: "\\b(noErr|kNilOptions|kInvalidID|kVariableLengthArray)\\b"
		name: "support.constant.mac-classic.c"
	}
	{
		match: '''
			(?x) \\b
			(AbsoluteTime|Boolean|Byte|ByteCount|ByteOffset|BytePtr|CompTimeValue|ConstLogicalAddress|ConstStrFileNameParam
			|ConstStringPtr|Duration|Fixed|FixedPtr|Float32|Float32Point|Float64|Float80|Float96|FourCharCode|Fract|FractPtr
			|Handle|ItemCount|LogicalAddress|OptionBits|OSErr|OSStatus|OSType|OSTypePtr|PhysicalAddress|ProcessSerialNumber
			|ProcessSerialNumberPtr|ProcHandle|Ptr|ResType|ResTypePtr|ShortFixed|ShortFixedPtr|SignedByte|SInt16|SInt32|SInt64
			|SInt8|Size|StrFileName|StringHandle|StringPtr|TimeBase|TimeRecord|TimeScale|TimeValue|TimeValue64|UInt16|UInt32
			|UInt64|UInt8|UniChar|UniCharCount|UniCharCountPtr|UniCharPtr|UnicodeScalarValue|UniversalProcHandle|UniversalProcPtr
			|UnsignedFixed|UnsignedFixedPtr|UnsignedWide|UTF16Char|UTF32Char|UTF8Char)
			\\b
		'''
		name: "support.type.mac-classic.c"
	}
	{
		match: "\\b([A-Za-z0-9_]+_t)\\b"
		name: "support.type.posix-reserved.c"
	}
	{
		include: "#block"
	}
	{
		include: "#parens"
	}
	{
		begin: '''
			(?x)
			(?!(?:while|for|do|if|else|switch|catch|enumerate|return|typeid|alignof|alignas|sizeof|[cr]?iterate|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas|asm|__asm__|auto|bool|_Bool|char|_Complex|double|enum|float|_Imaginary|int|long|short|signed|struct|typedef|union|unsigned|void)\\s*\\()
			(?=
			  (?:[A-Za-z_][A-Za-z0-9_]*+|::)++\\s*\\(  # actual name
			  |
			  (?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\\s*\\(
			)
		'''
		end: "(?<=\\))(?!\\w)"
		name: "meta.function.c"
		patterns: [
			{
				include: "#function-innards"
			}
		]
	}
	{
		include: "#line_continuation_character"
	}
	{
		name: "storage.modifier.array.bracket.square.c"
		match: "\\[\\s*\\]"
	}
	{
		name: "meta.bracket.square.access.c"
		begin: "([a-zA-Z_][a-zA-Z_0-9]*|(?<=[\\]\\)]))(\\[)"
		beginCaptures:
			"1":
				name: "variable.object.c"
			"2":
				name: "punctuation.definition.begin.bracket.square.c"
		end: "\\]"
		endCaptures:
			"0":
				name: "punctuation.definition.end.bracket.square.c"
		patterns: [
			{
				include: "#function-call-innards"
			}
		]
	}
	{
		match: ";"
		name: "punctuation.terminator.statement.c"
	}
	{
		match: ","
		name: "punctuation.separator.delimiter.c"
	}
]
repository:
	probably_a_parameter:
		match: "(?-mix:([a-zA-Z_][a-zA-Z_0-9]*)\\s*(?==)|(?<=[&*>a-zA-Z0-9_\\]\\)])\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*(?=,|\\)))"
		captures:
			"1":
				name: "variable.parameter.probably.defaulted.c"
			"2":
				name: "variable.parameter.probably.c"
	operator_overload:
		begin: "((?:\\b[A-Za-z_][A-Za-z0-9_]*\\b::)*)(operator)([-*&<>=+!][-*&<>=+!]?|\\(\\)|\\[\\])\\s*(\\()"
		beginCaptures:
			"1":
				name: "entity.scope.c"
			"2":
				name: "keyword.operator.overload.c"
			"3":
				name: "keyword.operator.overloadee.c"
			"4":
				name: "punctuation.section.parameters.begin.bracket.round.c"
		end: "\\)"
		endCaptures:
			"0":
				name: "punctuation.section.parameters.end.bracket.round.c"
		name: "meta.function.c"
		patterns: [
			{
				include: "#probably_a_parameter"
			}
			{
				include: "#function-innards"
			}
		]
	"access-method":
		name: "meta.function-call.member.c"
		begin: "([a-zA-Z_][a-zA-Z_0-9]*|(?<=[\\]\\)]))\\s*(?:(\\.)|(->))((?:(?:[a-zA-Z_][a-zA-Z_0-9]*)\\s*(?:(?:\\.)|(?:->)))*)\\s*([a-zA-Z_][a-zA-Z_0-9]*)(\\()"
		beginCaptures:
			"1":
				name: "variable.object.c"
			"2":
				name: "punctuation.separator.dot-access.c"
			"3":
				name: "punctuation.separator.pointer-access.c"
			"4":
				patterns: [
					{
						match: "\\."
						name: "punctuation.separator.dot-access.c"
					}
					{
						match: "->"
						name: "punctuation.separator.pointer-access.c"
					}
					{
						match: "[a-zA-Z_][a-zA-Z_0-9]*"
						name: "variable.object.c"
					}
					{
						name: "everything.else"
						match: ".+"
					}
				]
			"5":
				name: "entity.name.function.member.c"
			"6":
				name: "punctuation.section.arguments.begin.bracket.round.function.member.c"
		end: "\\)"
		endCaptures:
			"0":
				name: "punctuation.section.arguments.end.bracket.round.function.member.c"
		patterns: [
			{
				include: "#function-call-innards"
			}
		]
	"access-member":
		match: "([a-zA-Z_][a-zA-Z_0-9]*|(?<=[\\]\\)]))\\s*(?:(\\.)|(->))((?:(?:[a-zA-Z_][a-zA-Z_0-9]*)\\s*(?:(?:\\.)|(?:->)))*)\\s*([a-zA-Z_][a-zA-Z_0-9]*)"
		captures:
			"1":
				name: "variable.object.c"
			"2":
				name: "punctuation.separator.dot-access.c"
			"3":
				name: "punctuation.separator.pointer-access.c"
			"4":
				patterns: [
					{
						match: "\\."
						name: "punctuation.separator.dot-access.c"
					}
					{
						match: "->"
						name: "punctuation.separator.pointer-access.c"
					}
					{
						match: "[a-zA-Z_][a-zA-Z_0-9]*"
						name: "variable.object.c"
					}
					{
						name: "everything.else"
						match: ".+"
					}
				]
			"5":
				name: "variable.other.member.c"
	block:
		patterns: [
			{
				begin: "{"
				beginCaptures:
					"0":
						name: "punctuation.section.block.begin.bracket.curly.c"
				end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)"
				endCaptures:
					"0":
						name: "punctuation.section.block.end.bracket.curly.c"
				name: "meta.block.c"
				patterns: [
					{
						include: "#block_innards"
					}
				]
			}
		]
	block_innards:
		patterns: [
			{
				include: "#preprocessor-rule-enabled-block"
			}
			{
				include: "#preprocessor-rule-disabled-block"
			}
			{
				include: "#preprocessor-rule-conditional-block"
			}
			{
				include: "#access-method"
			}
			{
				include: "#access-member"
			}
			{
				include: "#c_function_call"
			}
			{
				name: "meta.initialization.c"
				begin: '''
					(?x)
					(?:
					  (?:
						(?=\\s)(?<!else|new|return)
						(?<=\\w) \\s+  # or word + space before name
					  )
					)
					(
					  (?:[A-Za-z_][A-Za-z0-9_]*+ | :: )++   # actual name
					  |
					  (?:(?<=operator) (?:[-*&<>=+!]+ | \\(\\) | \\[\\]))
					)
					\\s*(\\() # opening bracket
				'''
				beginCaptures:
					"1":
						name: "variable.other.c"
					"2":
						name: "punctuation.section.parens.begin.bracket.round.initialization.c"
				end: "\\)"
				endCaptures:
					"0":
						name: "punctuation.section.parens.end.bracket.round.initialization.c"
				patterns: [
					{
						include: "#function-call-innards"
					}
				]
			}
			{
				begin: "{"
				beginCaptures:
					"0":
						name: "punctuation.section.block.begin.bracket.curly.c"
				end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)"
				endCaptures:
					"0":
						name: "punctuation.section.block.end.bracket.curly.c"
				patterns: [
					{
						include: "#block_innards"
					}
				]
			}
			{
				include: "#parens-block"
			}
			{
				include: "$base"
			}
		]
	c_function_call:
		begin: '''
			(?x)
			(?!(?:while|for|do|if|else|switch|catch|enumerate|return|typeid|alignof|alignas|sizeof|[cr]?iterate|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()
			(?=
			(?:[A-Za-z_][A-Za-z0-9_]*+|::)++\\s*\\(  # actual name
			|
			(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\\s*\\(
			)
		'''
		end: "(?<=\\))(?!\\w)"
		name: "meta.function-call.c"
		patterns: [
			{
				include: "#function-call-innards"
			}
		]
	comments:
		patterns: [
			{
				captures:
					"1":
						name: "meta.toc-list.banner.block.c"
				match: "^/\\* =(\\s*.*?)\\s*= \\*/$\\n?"
				name: "comment.block.c"
			}
			{
				begin: "/\\*"
				beginCaptures:
					"0":
						name: "punctuation.definition.comment.begin.c"
				end: "\\*/"
				endCaptures:
					"0":
						name: "punctuation.definition.comment.end.c"
				name: "comment.block.c"
			}
			{
				match: "\\*/.*\\n"
				name: "invalid.illegal.stray-comment-end.c"
			}
			{
				captures:
					"1":
						name: "meta.toc-list.banner.line.c"
				match: "^// =(\\s*.*?)\\s*=\\s*$\\n?"
				name: "comment.line.banner.cpp"
			}
			{
				begin: "(^[ \\t]+)?(?=//)"
				beginCaptures:
					"1":
						name: "punctuation.whitespace.comment.leading.cpp"
				end: "(?!\\G)"
				patterns: [
					{
						begin: "//"
						beginCaptures:
							"0":
								name: "punctuation.definition.comment.cpp"
						end: "(?=\\n)"
						name: "comment.line.double-slash.cpp"
						patterns: [
							{
								include: "#line_continuation_character"
							}
						]
					}
				]
			}
		]
	disabled:
		begin: "^\\s*#\\s*if(n?def)?\\b.*$"
		end: "^\\s*#\\s*endif\\b"
		patterns: [
			{
				include: "#disabled"
			}
			{
				include: "#pragma-mark"
			}
		]
	line_continuation_character:
		patterns: [
			{
				match: "(\\\\)\\n"
				captures:
					"1":
						name: "constant.character.escape.line-continuation.c"
			}
		]
	numbers:
		patterns: [
			{
				match: "\\b((0(x|X)[0-9a-fA-F]([0-9a-fA-F']*[0-9a-fA-F])?)|(0(b|B)[01]([01']*[01])?)|(([0-9]([0-9']*[0-9])?\\.?[0-9]*([0-9']*[0-9])?)|(\\.[0-9]([0-9']*[0-9])?))((e|E)(\\+|-)?[0-9]([0-9']*[0-9])?)?)(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\b"
				name: "constant.numeric.c"
			}
		]
	parens:
		begin: "\\("
		beginCaptures:
			"0":
				name: "punctuation.section.parens.begin.bracket.round.c"
		end: "\\)"
		endCaptures:
			"0":
				name: "punctuation.section.parens.end.bracket.round.c"
		patterns: [
			{
				include: "$base"
			}
		]
	"parens-block":
		begin: "\\("
		beginCaptures:
			"0":
				name: "punctuation.section.parens.begin.bracket.round.c"
		end: "\\)"
		endCaptures:
			"0":
				name: "punctuation.section.parens.end.bracket.round.c"
		patterns: [
			{
				include: "#block_innards"
			}
		]
	"pragma-mark":
		captures:
			"1":
				name: "meta.preprocessor.pragma.c"
			"2":
				name: "keyword.control.directive.pragma.pragma-mark.c"
			"3":
				name: "punctuation.definition.directive.c"
			"4":
				name: "entity.name.tag.pragma-mark.c"
		match: "^\\s*(((#)\\s*pragma\\s+mark)\\s+(.*))"
		name: "meta.section"
	operators:
		patterns: [
			{
				match: "(?<![\\w$])(sizeof)(?![\\w$])"
				name: "keyword.operator.sizeof.c"
			}
			{
				match: "--"
				name: "keyword.operator.decrement.c"
			}
			{
				match: "\\+\\+"
				name: "keyword.operator.increment.c"
			}
			{
				match: "%=|\\+=|-=|\\*=|(?<!\\()/="
				name: "keyword.operator.assignment.compound.c"
			}
			{
				match: "&=|\\^=|<<=|>>=|\\|="
				name: "keyword.operator.assignment.compound.bitwise.c"
			}
			{
				match: "<<|>>"
				name: "keyword.operator.bitwise.shift.c"
			}
			{
				match: "!=|<=|>=|==|<|>"
				name: "keyword.operator.comparison.c"
			}
			{
				match: "&&|!|\\|\\|"
				name: "keyword.operator.logical.c"
			}
			{
				match: "&|\\||\\^|~"
				name: "keyword.operator.c"
			}
			{
				match: "="
				name: "keyword.operator.assignment.c"
			}
			{
				match: "%|\\*|/|-|\\+"
				name: "keyword.operator.c"
			}
			{
				begin: "\\?"
				beginCaptures:
					"0":
						name: "keyword.operator.ternary.c"
				end: ":"
				applyEndPatternLast: true
				endCaptures:
					"0":
						name: "keyword.operator.ternary.c"
				patterns: [
					{
						include: "#access-method"
					}
					{
						include: "#access-member"
					}
					{
						include: "#c_function_call"
					}
					{
						include: "$base"
					}
				]
			}
		]
	strings:
		patterns: [
			{
				begin: "\""
				beginCaptures:
					"0":
						name: "punctuation.definition.string.begin.c"
				end: "\""
				endCaptures:
					"0":
						name: "punctuation.definition.string.end.c"
				name: "string.quoted.double.c"
				patterns: [
					{
						include: "#string_escaped_char"
					}
					{
						include: "#string_placeholder"
					}
					{
						include: "#line_continuation_character"
					}
				]
			}
			{
				begin: "'"
				beginCaptures:
					"0":
						name: "punctuation.definition.string.begin.c"
				end: "'"
				endCaptures:
					"0":
						name: "punctuation.definition.string.end.c"
				name: "string.quoted.single.c"
				patterns: [
					{
						include: "#string_escaped_char"
					}
					{
						include: "#line_continuation_character"
					}
				]
			}
		]
	string_escaped_char:
		patterns: [
			{
				match: '''
					(?x)\\\\ (
					\\\\			 |
					[abefnprtv'"?]   |
					[0-3]\\d{,2}	 |
					[4-7]\\d?		|
					x[a-fA-F0-9]{,2} |
					u[a-fA-F0-9]{,4} |
					U[a-fA-F0-9]{,8} )
				'''
				name: "constant.character.escape.c"
			}
			{
				match: "\\\\."
				name: "invalid.illegal.unknown-escape.c"
			}
		]
	string_placeholder:
		patterns: [
			{
				match: '''
					(?x) %
					(\\d+\\$)?						   # field (argument #)
					[#0\\- +']*						  # flags
					[,;:_]?							  # separator character (AltiVec)
					((-?\\d+)|\\*(-?\\d+\\$)?)?		  # minimum field width
					(\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?	# precision
					(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)? # length modifier
					[diouxXDOUeEfFgGaACcSspn%]		   # conversion type
				'''
				name: "constant.other.placeholder.c"
			}
			{
				match: "(%)(?!\"\\s*(PRI|SCN))"
				captures:
					"1":
						name: "invalid.illegal.placeholder.c"
			}
		]
	storage_types:
		patterns: [
			{
				match: "\\b(asm|__asm__|auto|bool|_Bool|char|_Complex|double|enum|float|_Imaginary|int|long|short|signed|struct|typedef|union|unsigned|void)\\b"
				name: "storage.type.c"
			}
		]
	vararg_ellipses:
		match: "(?<!\\.)\\.\\.\\.(?!\\.)"
		name: "punctuation.vararg-ellipses.c"
	"preprocessor-rule-conditional":
		patterns: [
			{
				begin: "^\\s*((#)\\s*if(?:n?def)?\\b)"
				beginCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				end: "^\\s*((#)\\s*endif\\b)"
				endCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				patterns: [
					{
						begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
						end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)"
						name: "meta.preprocessor.c"
						patterns: [
							{
								include: "#preprocessor-rule-conditional-line"
							}
						]
					}
					{
						include: "#preprocessor-rule-enabled-elif"
					}
					{
						include: "#preprocessor-rule-enabled-else"
					}
					{
						include: "#preprocessor-rule-disabled-elif"
					}
					{
						begin: "^\\s*((#)\\s*elif\\b)"
						beginCaptures:
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)"
						name: "meta.preprocessor.c"
						patterns: [
							{
								include: "#preprocessor-rule-conditional-line"
							}
						]
					}
					{
						include: "$base"
					}
				]
			}
			{
				match: "^\\s*#\\s*(else|elif|endif)\\b"
				captures:
					"0":
						name: "invalid.illegal.stray-$1.c"
			}
		]
	"preprocessor-rule-conditional-block":
		patterns: [
			{
				begin: "^\\s*((#)\\s*if(?:n?def)?\\b)"
				beginCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				end: "^\\s*((#)\\s*endif\\b)"
				endCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				patterns: [
					{
						begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
						end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)"
						name: "meta.preprocessor.c"
						patterns: [
							{
								include: "#preprocessor-rule-conditional-line"
							}
						]
					}
					{
						include: "#preprocessor-rule-enabled-elif-block"
					}
					{
						include: "#preprocessor-rule-enabled-else-block"
					}
					{
						include: "#preprocessor-rule-disabled-elif"
					}
					{
						begin: "^\\s*((#)\\s*elif\\b)"
						beginCaptures:
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)"
						name: "meta.preprocessor.c"
						patterns: [
							{
								include: "#preprocessor-rule-conditional-line"
							}
						]
					}
					{
						include: "#block_innards"
					}
				]
			}
			{
				match: "^\\s*#\\s*(else|elif|endif)\\b"
				captures:
					"0":
						name: "invalid.illegal.stray-$1.c"
			}
		]
	"preprocessor-rule-conditional-line":
		patterns: [
			{
				match: "(?:\\bdefined\\b\\s*$)|(?:\\bdefined\\b(?=\\s*\\(*\\s*(?:(?!defined\\b)[a-zA-Z_$][\\w$]*\\b)\\s*\\)*\\s*(?:\\n|//|/\\*|\\?|\\:|&&|\\|\\||\\\\\\s*\\n)))"
				name: "keyword.control.directive.conditional.c"
			}
			{
				match: "\\bdefined\\b"
				name: "invalid.illegal.macro-name.c"
			}
			{
				include: "#comments"
			}
			{
				include: "#strings"
			}
			{
				include: "#numbers"
			}
			{
				begin: "\\?"
				beginCaptures:
					"0":
						name: "keyword.operator.ternary.c"
				end: ":"
				endCaptures:
					"0":
						name: "keyword.operator.ternary.c"
				patterns: [
					{
						include: "#preprocessor-rule-conditional-line"
					}
				]
			}
			{
				include: "#operators"
			}
			{
				match: "\\b(NULL|true|false|TRUE|FALSE)\\b"
				name: "constant.language.c"
			}
			{
				match: "[a-zA-Z_$][\\w$]*"
				name: "entity.name.function.preprocessor.c"
			}
			{
				include: "#line_continuation_character"
			}
			{
				begin: "\\("
				beginCaptures:
					"0":
						name: "punctuation.section.parens.begin.bracket.round.c"
				end: "\\)|(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)"
				endCaptures:
					"0":
						name: "punctuation.section.parens.end.bracket.round.c"
				patterns: [
					{
						include: "#preprocessor-rule-conditional-line"
					}
				]
			}
		]
	"preprocessor-rule-disabled":
		patterns: [
			{
				begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))"
				beginCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				end: "^\\s*((#)\\s*endif\\b)"
				endCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				patterns: [
					{
						begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
						end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)"
						name: "meta.preprocessor.c"
						patterns: [
							{
								include: "#preprocessor-rule-conditional-line"
							}
						]
					}
					{
						include: "#comments"
					}
					{
						include: "#preprocessor-rule-enabled-elif"
					}
					{
						include: "#preprocessor-rule-enabled-else"
					}
					{
						include: "#preprocessor-rule-disabled-elif"
					}
					{
						begin: "^\\s*((#)\\s*elif\\b)"
						beginCaptures:
							"0":
								name: "meta.preprocessor.c"
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))"
						patterns: [
							{
								begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
								end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)"
								name: "meta.preprocessor.c"
								patterns: [
									{
										include: "#preprocessor-rule-conditional-line"
									}
								]
							}
							{
								include: "$base"
							}
						]
					}
					{
						begin: "\\n"
						end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))"
						contentName: "comment.block.preprocessor.if-branch.c"
						patterns: [
							{
								include: "#disabled"
							}
							{
								include: "#pragma-mark"
							}
						]
					}
				]
			}
		]
	"preprocessor-rule-disabled-block":
		patterns: [
			{
				begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))"
				beginCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				end: "^\\s*((#)\\s*endif\\b)"
				endCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				patterns: [
					{
						begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
						end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)"
						name: "meta.preprocessor.c"
						patterns: [
							{
								include: "#preprocessor-rule-conditional-line"
							}
						]
					}
					{
						include: "#comments"
					}
					{
						include: "#preprocessor-rule-enabled-elif-block"
					}
					{
						include: "#preprocessor-rule-enabled-else-block"
					}
					{
						include: "#preprocessor-rule-disabled-elif"
					}
					{
						begin: "^\\s*((#)\\s*elif\\b)"
						beginCaptures:
							"0":
								name: "meta.preprocessor.c"
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))"
						patterns: [
							{
								begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
								end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)"
								name: "meta.preprocessor.c"
								patterns: [
									{
										include: "#preprocessor-rule-conditional-line"
									}
								]
							}
							{
								include: "#block_innards"
							}
						]
					}
					{
						begin: "\\n"
						end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))"
						contentName: "comment.block.preprocessor.if-branch.in-block.c"
						patterns: [
							{
								include: "#disabled"
							}
							{
								include: "#pragma-mark"
							}
						]
					}
				]
			}
		]
	"preprocessor-rule-disabled-elif":
		begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))"
		beginCaptures:
			"0":
				name: "meta.preprocessor.c"
			"1":
				name: "keyword.control.directive.conditional.c"
			"2":
				name: "punctuation.definition.directive.c"
		end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))"
		patterns: [
			{
				begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
				end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)"
				name: "meta.preprocessor.c"
				patterns: [
					{
						include: "#preprocessor-rule-conditional-line"
					}
				]
			}
			{
				include: "#comments"
			}
			{
				begin: "\\n"
				end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))"
				contentName: "comment.block.preprocessor.elif-branch.c"
				patterns: [
					{
						include: "#disabled"
					}
					{
						include: "#pragma-mark"
					}
				]
			}
		]
	"preprocessor-rule-enabled":
		patterns: [
			{
				begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))"
				beginCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
					"3":
						name: "constant.numeric.preprocessor.c"
				end: "^\\s*((#)\\s*endif\\b)"
				endCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				patterns: [
					{
						begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
						end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)"
						name: "meta.preprocessor.c"
						patterns: [
							{
								include: "#preprocessor-rule-conditional-line"
							}
						]
					}
					{
						include: "#comments"
					}
					{
						begin: "^\\s*((#)\\s*else\\b)"
						beginCaptures:
							"0":
								name: "meta.preprocessor.c"
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=^\\s*((#)\\s*endif\\b))"
						contentName: "comment.block.preprocessor.else-branch.c"
						patterns: [
							{
								include: "#disabled"
							}
							{
								include: "#pragma-mark"
							}
						]
					}
					{
						begin: "^\\s*((#)\\s*elif\\b)"
						beginCaptures:
							"0":
								name: "meta.preprocessor.c"
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))"
						contentName: "comment.block.preprocessor.if-branch.c"
						patterns: [
							{
								include: "#disabled"
							}
							{
								include: "#pragma-mark"
							}
						]
					}
					{
						begin: "\\n"
						end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))"
						patterns: [
							{
								include: "$base"
							}
						]
					}
				]
			}
		]
	"preprocessor-rule-enabled-block":
		patterns: [
			{
				begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))"
				beginCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				end: "^\\s*((#)\\s*endif\\b)"
				endCaptures:
					"0":
						name: "meta.preprocessor.c"
					"1":
						name: "keyword.control.directive.conditional.c"
					"2":
						name: "punctuation.definition.directive.c"
				patterns: [
					{
						begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
						end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)"
						name: "meta.preprocessor.c"
						patterns: [
							{
								include: "#preprocessor-rule-conditional-line"
							}
						]
					}
					{
						include: "#comments"
					}
					{
						begin: "^\\s*((#)\\s*else\\b)"
						beginCaptures:
							"0":
								name: "meta.preprocessor.c"
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=^\\s*((#)\\s*endif\\b))"
						contentName: "comment.block.preprocessor.else-branch.in-block.c"
						patterns: [
							{
								include: "#disabled"
							}
							{
								include: "#pragma-mark"
							}
						]
					}
					{
						begin: "^\\s*((#)\\s*elif\\b)"
						beginCaptures:
							"0":
								name: "meta.preprocessor.c"
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))"
						contentName: "comment.block.preprocessor.if-branch.in-block.c"
						patterns: [
							{
								include: "#disabled"
							}
							{
								include: "#pragma-mark"
							}
						]
					}
					{
						begin: "\\n"
						end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))"
						patterns: [
							{
								include: "#block_innards"
							}
						]
					}
				]
			}
		]
	"preprocessor-rule-enabled-elif":
		begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))"
		beginCaptures:
			"0":
				name: "meta.preprocessor.c"
			"1":
				name: "keyword.control.directive.conditional.c"
			"2":
				name: "punctuation.definition.directive.c"
		end: "(?=^\\s*((#)\\s*endif\\b))"
		patterns: [
			{
				begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
				end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)"
				name: "meta.preprocessor.c"
				patterns: [
					{
						include: "#preprocessor-rule-conditional-line"
					}
				]
			}
			{
				include: "#comments"
			}
			{
				begin: "\\n"
				end: "(?=^\\s*((#)\\s*(?:endif)\\b))"
				patterns: [
					{
						begin: "^\\s*((#)\\s*(else)\\b)"
						beginCaptures:
							"0":
								name: "meta.preprocessor.c"
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=^\\s*((#)\\s*endif\\b))"
						contentName: "comment.block.preprocessor.elif-branch.c"
						patterns: [
							{
								include: "#disabled"
							}
							{
								include: "#pragma-mark"
							}
						]
					}
					{
						begin: "^\\s*((#)\\s*(elif)\\b)"
						beginCaptures:
							"0":
								name: "meta.preprocessor.c"
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))"
						contentName: "comment.block.preprocessor.elif-branch.c"
						patterns: [
							{
								include: "#disabled"
							}
							{
								include: "#pragma-mark"
							}
						]
					}
					{
						include: "$base"
					}
				]
			}
		]
	"preprocessor-rule-enabled-elif-block":
		begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))"
		beginCaptures:
			"0":
				name: "meta.preprocessor.c"
			"1":
				name: "keyword.control.directive.conditional.c"
			"2":
				name: "punctuation.definition.directive.c"
		end: "(?=^\\s*((#)\\s*endif\\b))"
		patterns: [
			{
				begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))"
				end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)"
				name: "meta.preprocessor.c"
				patterns: [
					{
						include: "#preprocessor-rule-conditional-line"
					}
				]
			}
			{
				include: "#comments"
			}
			{
				begin: "\\n"
				end: "(?=^\\s*((#)\\s*(?:endif)\\b))"
				patterns: [
					{
						begin: "^\\s*((#)\\s*(else)\\b)"
						beginCaptures:
							"0":
								name: "meta.preprocessor.c"
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=^\\s*((#)\\s*endif\\b))"
						contentName: "comment.block.preprocessor.elif-branch.in-block.c"
						patterns: [
							{
								include: "#disabled"
							}
							{
								include: "#pragma-mark"
							}
						]
					}
					{
						begin: "^\\s*((#)\\s*(elif)\\b)"
						beginCaptures:
							"0":
								name: "meta.preprocessor.c"
							"1":
								name: "keyword.control.directive.conditional.c"
							"2":
								name: "punctuation.definition.directive.c"
						end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))"
						contentName: "comment.block.preprocessor.elif-branch.c"
						patterns: [
							{
								include: "#disabled"
							}
							{
								include: "#pragma-mark"
							}
						]
					}
					{
						include: "#block_innards"
					}
				]
			}
		]
	"preprocessor-rule-enabled-else":
		begin: "^\\s*((#)\\s*else\\b)"
		beginCaptures:
			"0":
				name: "meta.preprocessor.c"
			"1":
				name: "keyword.control.directive.conditional.c"
			"2":
				name: "punctuation.definition.directive.c"
		end: "(?=^\\s*((#)\\s*endif\\b))"
		patterns: [
			{
				include: "$base"
			}
		]
	"preprocessor-rule-enabled-else-block":
		begin: "^\\s*((#)\\s*else\\b)"
		beginCaptures:
			"0":
				name: "meta.preprocessor.c"
			"1":
				name: "keyword.control.directive.conditional.c"
			"2":
				name: "punctuation.definition.directive.c"
		end: "(?=^\\s*((#)\\s*endif\\b))"
		patterns: [
			{
				include: "#block_innards"
			}
		]
	"preprocessor-rule-define-line-contents":
		patterns: [
			{
				include: "#vararg_ellipses"
			}
			{
				begin: "{"
				beginCaptures:
					"0":
						name: "punctuation.section.block.begin.bracket.curly.c"
				end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)|(?<!\\\\)(?=\\s*\\n)"
				endCaptures:
					"0":
						name: "punctuation.section.block.end.bracket.curly.c"
				name: "meta.block.c"
				patterns: [
					{
						include: "#preprocessor-rule-define-line-blocks"
					}
				]
			}
			{
				match: "\\("
				name: "punctuation.section.parens.begin.bracket.round.c"
			}
			{
				match: "\\)"
				name: "punctuation.section.parens.end.bracket.round.c"
			}
			{
				begin: '''
					(?x)
					(?!(?:while|for|do|if|else|switch|catch|enumerate|return|typeid|alignof|alignas|sizeof|[cr]?iterate|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas|asm|__asm__|auto|bool|_Bool|char|_Complex|double|enum|float|_Imaginary|int|long|short|signed|struct|typedef|union|unsigned|void)\\s*\\()
					(?=
					  (?:[A-Za-z_][A-Za-z0-9_]*+|::)++\\s*\\(  # actual name
					  |
					  (?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\\s*\\(
					)
				'''
				end: "(?<=\\))(?!\\w)|(?<!\\\\)(?=\\s*\\n)"
				name: "meta.function.c"
				patterns: [
					{
						include: "#preprocessor-rule-define-line-functions"
					}
				]
			}
			{
				begin: "\""
				beginCaptures:
					"0":
						name: "punctuation.definition.string.begin.c"
				end: "\"|(?<!\\\\)(?=\\s*\\n)"
				endCaptures:
					"0":
						name: "punctuation.definition.string.end.c"
				name: "string.quoted.double.c"
				patterns: [
					{
						include: "#string_escaped_char"
					}
					{
						include: "#string_placeholder"
					}
					{
						include: "#line_continuation_character"
					}
				]
			}
			{
				begin: "'"
				beginCaptures:
					"0":
						name: "punctuation.definition.string.begin.c"
				end: "'|(?<!\\\\)(?=\\s*\\n)"
				endCaptures:
					"0":
						name: "punctuation.definition.string.end.c"
				name: "string.quoted.single.c"
				patterns: [
					{
						include: "#string_escaped_char"
					}
					{
						include: "#line_continuation_character"
					}
				]
			}
			{
				include: "#access-method"
			}
			{
				include: "#access-member"
			}
			{
				include: "$base"
			}
		]
	"preprocessor-rule-define-line-blocks":
		patterns: [
			{
				begin: "{"
				beginCaptures:
					"0":
						name: "punctuation.section.block.begin.bracket.curly.c"
				end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)|(?<!\\\\)(?=\\s*\\n)"
				endCaptures:
					"0":
						name: "punctuation.section.block.end.bracket.curly.c"
				patterns: [
					{
						include: "#preprocessor-rule-define-line-blocks"
					}
					{
						include: "#preprocessor-rule-define-line-contents"
					}
				]
			}
			{
				include: "#preprocessor-rule-define-line-contents"
			}
		]
	"preprocessor-rule-define-line-functions":
		patterns: [
			{
				include: "#comments"
			}
			{
				include: "#storage_types"
			}
			{
				include: "#vararg_ellipses"
			}
			{
				include: "#access-method"
			}
			{
				include: "#access-member"
			}
			{
				include: "#operators"
			}
			{
				begin: '''
					(?x)
					(?!(?:while|for|do|if|else|switch|catch|enumerate|return|typeid|alignof|alignas|sizeof|[cr]?iterate|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()
					(
					(?:[A-Za-z_][A-Za-z0-9_]*+|::)++  # actual name
					|
					(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))
					)
					\\s*(\\()
				'''
				beginCaptures:
					"1":
						name: "entity.name.function.c"
					"2":
						name: "punctuation.section.arguments.begin.bracket.round.c"
				end: "(\\))|(?<!\\\\)(?=\\s*\\n)"
				endCaptures:
					"1":
						name: "punctuation.section.arguments.end.bracket.round.c"
				patterns: [
					{
						include: "#preprocessor-rule-define-line-functions"
					}
				]
			}
			{
				begin: "\\("
				beginCaptures:
					"0":
						name: "punctuation.section.parens.begin.bracket.round.c"
				end: "(\\))|(?<!\\\\)(?=\\s*\\n)"
				endCaptures:
					"1":
						name: "punctuation.section.parens.end.bracket.round.c"
				patterns: [
					{
						include: "#preprocessor-rule-define-line-functions"
					}
				]
			}
			{
				include: "#preprocessor-rule-define-line-contents"
			}
		]
	"function-innards":
		patterns: [
			{
				include: "#comments"
			}
			{
				include: "#storage_types"
			}
			{
				include: "#operators"
			}
			{
				include: "#vararg_ellipses"
			}
			{
				name: "meta.function.definition.parameters"
				begin: '''
					(?x)
					(?!(?:while|for|do|if|else|switch|catch|enumerate|return|typeid|alignof|alignas|sizeof|[cr]?iterate|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()
					(
					(?:[A-Za-z_][A-Za-z0-9_]*+|::)++  # actual name
					|
					(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))
					)
					\\s*(\\()
				'''
				beginCaptures:
					"1":
						name: "entity.name.function.c"
					"2":
						name: "punctuation.section.parameters.begin.bracket.round.c"
				end: "\\)"
				endCaptures:
					"0":
						name: "punctuation.section.parameters.end.bracket.round.c"
				patterns: [
					{
						include: "#probably_a_parameter"
					}
					{
						include: "#function-innards"
					}
				]
			}
			{
				begin: "\\("
				beginCaptures:
					"0":
						name: "punctuation.section.parens.begin.bracket.round.c"
				end: "\\)"
				endCaptures:
					"0":
						name: "punctuation.section.parens.end.bracket.round.c"
				patterns: [
					{
						include: "#function-innards"
					}
				]
			}
			{
				include: "$base"
			}
		]
	"function-call-innards":
		patterns: [
			{
				include: "#comments"
			}
			{
				include: "#storage_types"
			}
			{
				include: "#access-method"
			}
			{
				include: "#access-member"
			}
			{
				include: "#operators"
			}
			{
				begin: '''
					(?x)
					(?!(?:while|for|do|if|else|switch|catch|enumerate|return|typeid|alignof|alignas|sizeof|[cr]?iterate|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()
					(
					(?:[A-Za-z_][A-Za-z0-9_]*+|::)++  # actual name
					|
					(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))
					)
					\\s*(\\()
				'''
				beginCaptures:
					"1":
						name: "entity.name.function.c"
					"2":
						name: "punctuation.section.arguments.begin.bracket.round.c"
				end: "\\)"
				endCaptures:
					"0":
						name: "punctuation.section.arguments.end.bracket.round.c"
				patterns: [
					{
						include: "#function-call-innards"
					}
				]
			}
			{
				begin: "\\("
				beginCaptures:
					"0":
						name: "punctuation.section.parens.begin.bracket.round.c"
				end: "\\)"
				endCaptures:
					"0":
						name: "punctuation.section.parens.end.bracket.round.c"
				patterns: [
					{
						include: "#function-call-innards"
					}
				]
			}
			{
				include: "#block_innards"
			}
		]